{
  "windows": {
    "6e9a354f-1167-43d7-bb28-dfd83aebb041": {
      "id": "6e9a354f-1167-43d7-bb28-dfd83aebb041",
      "window_type": "read_result",
      "content": [
        "\"\"\"Editor tool - unified file editing with persistent windows.\"\"\"",
        "",
        "from typing import Dict, Any, Optional",
        "from pathlib import Path",
        "from nisaba.tools.base import NisabaTool",
        "",
        "",
        "class EditorTool(NisabaTool):",
        "    \"\"\"",
        "    Unified file editor with persistent windows and change tracking.",
        "    ",
        "    Replaces nisaba_read, nisaba_write, nisaba_edit with single coherent interface.",
        "    \"\"\"",
        "    ",
        "    def __init__(self, factory):",
        "        super().__init__(factory)",
        "        self._manager = None",
        "    ",
        "    @property",
        "    def manager(self):",
        "        \"\"\"Lazy-initialize editor manager (persists across operations).\"\"\"",
        "        if self._manager is None:",
        "            from nisaba.tui.editor_manager import EditorManager",
        "            self._manager = EditorManager()",
        "        return self._manager",
        "    ",
        "    async def execute(",
        "        self,",
        "        operation: str,",
        "        file: Optional[str] = None,",
        "        content: Optional[str] = None,",
        "        editor_id: Optional[str] = None,",
        "        old_string: Optional[str] = None,",
        "        new_string: Optional[str] = None,",
        "        line_start: Optional[int] = 1,",
        "        line_end: Optional[int] = -1,",
        "        before_line: Optional[int] = None,",
        "        split_id: Optional[str] = None",
        "    ) -> Dict[str, Any]:",
        "        \"\"\"",
        "        Execute editor operation.",
        "        ",
        "        Operations:",
        "        - open: Open file in editor (returns existing if already open)",
        "        - write: Write content to file and open editor",
        "        - replace: Replace string in editor content",
        "        - insert: Insert content before specified line",
        "        - delete: Delete line range",
        "        - replace_lines: Replace line range with new content",
        "        - split: Create split view of editor",
        "        - resize: Resize editor or split window",
        "        - close_split: Close split view",
        "        - close: Close editor window (and all splits)",
        "        - close_all: Close all editor windows",
        "        - status: Get editor status summary",
        "        ",
        "        :meta pitch: Unified file editing with workspace persistence",
        "        :meta when: Reading, writing, or editing files",
        "        ",
        "        Args:",
        "            operation: Operation type",
        "            file: File path (for open, write)",
        "            content: File content (for write)",
        "            editor_id: Editor window ID (for replace, insert, delete, replace_lines, split, close)",
        "            old_string: String to replace (for replace)",
        "            new_string: Replacement string (for replace)",
        "            line_start: Start line for open/delete/replace_lines/split/resize (1-indexed, default 1)",
        "            line_end: End line for open/delete/replace_lines/split/resize (-1 = end of file, default -1)",
        "            before_line: Line to insert before (for insert)",
        "            split_id: Split ID (for close_split, resize)",
        "        ",
        "        Returns:",
        "            Dict with success status and operation result",
        "        \"\"\"",
        "        valid_ops = ['open', 'write', 'replace', 'insert', 'delete', 'replace_lines', 'split', 'resize', 'close_split', 'close', 'close_all', 'status']",
        "        ",
        "        if operation not in valid_ops:",
        "            return {",
        "                \"success\": False,",
        "                \"error\": f\"Invalid operation: {operation}. Valid: {valid_ops}\",",
        "                \"error_type\": \"ValueError\",",
        "                \"nisaba\": True",
        "            }",
        "        ",
        "        try:",
        "            if operation == 'open':",
        "                if not file:",
        "                    return self._error(\"'file' parameter required for open\")",
        "                ",
        "                editor_id = self.manager.open(file, line_start, line_end)",
        "                message = f\"Opened editor: {file}\"",
        "                result = {\"editor_id\": editor_id}",
        "            ",
        "            elif operation == 'write':",
        "                if not file or content is None:",
        "                    return self._error(\"'file' and 'content' parameters required for write\")",
        "                ",
        "                editor_id = self.manager.write(file, content)",
        "                message = f\"Wrote file: {file}\"",
        "                result = {\"editor_id\": editor_id}",
        "            ",
        "            elif operation == 'replace':",
        "                if not editor_id or not old_string or new_string is None:",
        "                    return self._error(\"'editor_id', 'old_string', 'new_string' required for replace\")",
        "                ",
        "                self.manager.replace(editor_id, old_string, new_string)",
        "                message = f\"Replaced in editor: {old_string[:30]}... \u2192 {new_string[:30]}...\"",
        "                result = {}",
        "            ",
        "            elif operation == 'insert':",
        "                if not editor_id or before_line is None or content is None:",
        "                    return self._error(\"'editor_id', 'before_line', 'content' required for insert\")",
        "                ",
        "                self.manager.insert(editor_id, before_line, content)",
        "                num_lines = len(content.split('\\n'))",
        "                message = f\"Inserted {num_lines} line(s) before line {before_line}\"",
        "                result = {}",
        "            ",
        "            elif operation == 'delete':",
        "                if not editor_id or line_start is None or line_end is None:",
        "                    return self._error(\"'editor_id', 'line_start', 'line_end' required for delete\")",
        "                ",
        "                self.manager.delete(editor_id, line_start, line_end)",
        "                message = f\"Deleted lines {line_start}-{line_end}\"",
        "                result = {}",
        "            ",
        "            elif operation == 'replace_lines':",
        "                if not editor_id or line_start is None or line_end is None or content is None:",
        "                    return self._error(\"'editor_id', 'line_start', 'line_end', 'content' required for replace_lines\")",
        "                ",
        "                self.manager.replace_lines(editor_id, line_start, line_end, content)",
        "                num_lines = len(content.split('\\n'))",
        "                message = f\"Replaced lines {line_start}-{line_end} with {num_lines} line(s)\"",
        "                result = {}",
        "            ",
        "            elif operation == 'split':",
        "                if not editor_id or line_start is None or line_end is None:",
        "                    return self._error(\"'editor_id', 'line_start', 'line_end' required for split\")",
        "                ",
        "                split_id = self.manager.split(editor_id, line_start, line_end)",
        "                message = f\"Created split view: lines {line_start}-{line_end}\"",
        "                result = {\"split_id\": split_id}",
        "            ",
        "            elif operation == 'resize':",
        "                window_id = split_id or editor_id",
        "                if not window_id or line_start is None or line_end is None:",
        "                    return self._error(\"'editor_id' or 'split_id', 'line_start', 'line_end' required for resize\")",
        "                ",
        "                self.manager.resize(window_id, line_start, line_end)",
        "                message = f\"Resized window to lines {line_start}-{line_end}\"",
        "                result = {}",
        "            ",
        "            elif operation == 'close_split':",
        "                if not split_id:",
        "                    return self._error(\"'split_id' parameter required for close_split\")",
        "                ",
        "                success = self.manager.close_split(split_id)",
        "                if not success:",
        "                    return self._error(f\"Split not found: {split_id}\")",
        "                ",
        "                message = \"Closed split\"",
        "                result = {}",
        "            ",
        "            elif operation == 'close':",
        "                if not editor_id:",
        "                    return self._error(\"'editor_id' parameter required for close\")",
        "                ",
        "                success = self.manager.close(editor_id)",
        "                if not success:",
        "                    return self._error(f\"Editor not found: {editor_id}\")",
        "                ",
        "                message = \"Closed editor\"",
        "                result = {}",
        "            ",
        "            elif operation == 'close_all':",
        "                self.manager.close_all()",
        "                message = \"Closed all editors\"",
        "                result = {}",
        "            ",
        "            elif operation == 'status':",
        "                status = self.manager.status()",
        "                message = f\"Editors: {status['editor_count']}, Total lines: {status['total_lines']}\"",
        "                result = status",
        "            ",
        "            # Render to markdown and write to file",
        "            rendered = self.manager.render()",
        "            output_file = Path.cwd() / \".nisaba\" / \"editor_windows.md\"",
        "            output_file.parent.mkdir(parents=True, exist_ok=True)",
        "            output_file.write_text(rendered, encoding='utf-8')",
        "            ",
        "            return {",
        "                \"success\": True,",
        "                \"message\": message,",
        "                \"nisaba\": True,",
        "                **result",
        "            }",
        "        ",
        "        except Exception as e:",
        "            self.logger.error(f\"Editor operation failed: {e}\", exc_info=True)",
        "            return {",
        "                \"success\": False,",
        "                \"error\": str(e),",
        "                \"error_type\": type(e).__name__,",
        "                \"nisaba\": True",
        "            }",
        "    ",
        "    def _error(self, msg: str) -> Dict[str, Any]:",
        "        \"\"\"Return error response.\"\"\"",
        "        return {",
        "            \"success\": False,",
        "            \"error\": msg,",
        "            \"error_type\": \"ValueError\",",
        "            \"nisaba\": True",
        "        }"
      ],
      "metadata": {
        "total_lines": 214
      },
      "opened_at": 1762532795.7239463,
      "file_path": "src/nisaba/tools/editor.py",
      "start_line": 1,
      "end_line": 214,
      "command": "",
      "exit_code": 0,
      "pattern": "",
      "glob_pattern": ""
    },
    "80077eb4-8377-4b1b-bd11-751cb5f816ef": {
      "id": "80077eb4-8377-4b1b-bd11-751cb5f816ef",
      "window_type": "read_result",
      "content": [
        "\"\"\"Editor manager - unified file editing with persistent windows.\"\"\"",
        "",
        "import json",
        "import logging",
        "import difflib",
        "import time",
        "from pathlib import Path",
        "from typing import Dict, List, Optional, Any",
        "",
        "from nisaba.tui.editor_window import EditorWindow, Edit",
        "",
        "logger = logging.getLogger(__name__)",
        "",
        "",
        "class EditorManager:",
        "    \"\"\"",
        "    Manages collection of editor windows.",
        "    ",
        "    Key features:",
        "    - One editor per file (no duplicates)",
        "    - Immediate commit to disk",
        "    - Change tracking with edit history",
        "    - Diff rendering with inline markers",
        "    \"\"\"",
        "    ",
        "    def __init__(self):",
        "        self.editors: Dict[Path, EditorWindow] = {}  # file_path \u2192 editor",
        "        self.state_file = Path.cwd() / \".nisaba\" / \"editor_state.json\"",
        "        self.output_file = Path.cwd() / \".nisaba\" / \"editor_windows.md\"",
        "        self.load_state()",
        "    ",
        "    def open(self, file: str, line_start: int = 1, line_end: int = -1) -> str:",
        "        \"\"\"",
        "        Open file in editor. Returns existing editor_id if already open.",
        "        ",
        "        Args:",
        "            file: File path",
        "            line_start: Start line (1-indexed)",
        "            line_end: End line (-1 = end of file, inclusive)",
        "        ",
        "        Returns:",
        "            editor_id",
        "        \"\"\"",
        "        file_path = Path(file).resolve()",
        "        ",
        "        # Return existing editor if already open",
        "        if file_path in self.editors:",
        "            logger.info(f\"File already open: {file_path}\")",
        "            return self.editors[file_path].id",
        "        ",
        "        # Read file",
        "        try:",
        "            with open(file_path, 'r', encoding='utf-8') as f:",
        "                all_lines = f.readlines()",
        "            ",
        "            # Strip newlines",
        "            all_lines = [line.rstrip('\\n') for line in all_lines]",
        "            ",
        "            # Handle line range",
        "            if line_end == -1:",
        "                content = all_lines[line_start-1:] if line_start > 1 else all_lines",
        "                actual_end = len(all_lines)",
        "            else:",
        "                content = all_lines[line_start-1:line_end]",
        "                actual_end = line_end",
        "            ",
        "            # Get file mtime",
        "            mtime = file_path.stat().st_mtime",
        "            ",
        "            # Create editor",
        "            editor = EditorWindow(",
        "                file_path=file_path,",
        "                line_start=line_start,",
        "                line_end=actual_end,",
        "                content=content,",
        "                original_content=content.copy(),",
        "                edits=[],",
        "                last_mtime=mtime",
        "            )",
        "            ",
        "            self.editors[file_path] = editor",
        "            self.save_state()",
        "            ",
        "            logger.info(f\"Opened editor: {file_path} ({len(content)} lines)\")",
        "            return editor.id",
        "            ",
        "        except Exception as e:",
        "            logger.error(f\"Failed to open {file_path}: {e}\", exc_info=True)",
        "            raise",
        "    ",
        "    def write(self, file: str, content: str) -> str:",
        "        \"\"\"",
        "        Write content to file and open editor.",
        "        ",
        "        Args:",
        "            file: File path",
        "            content: File content",
        "        ",
        "        Returns:",
        "            editor_id",
        "        \"\"\"",
        "        file_path = Path(file).resolve()",
        "        ",
        "        try:",
        "            # Create parent directories",
        "            file_path.parent.mkdir(parents=True, exist_ok=True)",
        "            ",
        "            # Write to disk",
        "            file_path.write_text(content, encoding='utf-8')",
        "            logger.info(f\"Wrote file: {file_path}\")",
        "            ",
        "            # Open editor (will create new or return existing)",
        "            editor_id = self.open(str(file_path))",
        "            self._add_notification(f\"\u2713 editor.write() \u2192 created {file_path.name}\")",
        "            return editor_id",
        "            ",
        "        except Exception as e:",
        "            logger.error(f\"Failed to write {file_path}: {e}\", exc_info=True)",
        "            raise",
        "    ",
        "    def replace(self, editor_id: str, old_string: str, new_string: str) -> bool:",
        "        \"\"\"",
        "        Replace string in editor content and write to disk.",
        "        ",
        "        Args:",
        "            editor_id: Editor window ID",
        "            old_string: String to replace",
        "            new_string: Replacement string",
        "        ",
        "        Returns:",
        "            True if successful",
        "        \"\"\"",
        "        editor = self._get_editor_by_id(editor_id)",
        "        if not editor:",
        "            raise ValueError(f\"Editor not found: {editor_id}\")",
        "        ",
        "        # Check if string exists",
        "        full_content = '\\n'.join(editor.content)",
        "        if old_string not in full_content:",
        "            raise ValueError(f\"String not found in editor: {old_string[:50]}...\")",
        "        ",
        "        # Apply replacement",
        "        old_content_lines = editor.content.copy()",
        "        new_content_lines = [line.replace(old_string, new_string) for line in editor.content]",
        "        ",
        "        # Track edit",
        "        edit = Edit(",
        "            timestamp=time.time(),",
        "            operation='replace',",
        "            target=old_string,",
        "            old_content='\\n'.join(old_content_lines),",
        "            new_content='\\n'.join(new_content_lines)",
        "        )",
        "        ",
        "        editor.edits.append(edit)",
        "        editor.content = new_content_lines",
        "        ",
        "        # Write to disk immediately",
        "        self._write_to_disk(editor)",
        "        self.save_state()",
        "        ",
        "        self._add_notification(f\"\u2713 editor.replace() \u2192 {editor.file_path.name} (string replaced)\")",
        "        logger.info(f\"Replaced in {editor.file_path}: {old_string[:30]}... \u2192 {new_string[:30]}...\")",
        "        return True",
        "    ",
        "    def insert(self, editor_id: str, before_line: int, content: str) -> bool:",
        "        \"\"\"",
        "        Insert content before specified line.",
        "        ",
        "        Args:",
        "            editor_id: Editor window ID",
        "            before_line: Line number to insert before (1-indexed, relative to editor view)",
        "            content: Content to insert (can be multi-line string)",
        "        ",
        "        Returns:",
        "            True if successful",
        "        \"\"\"",
        "        editor = self._get_editor_by_id(editor_id)",
        "        if not editor:",
        "            raise ValueError(f\"Editor not found: {editor_id}\")",
        "        ",
        "        # Validate line number",
        "        if before_line < editor.line_start or before_line > editor.line_end + 1:",
        "            raise ValueError(f\"Line {before_line} out of range ({editor.line_start}-{editor.line_end})\")",
        "        ",
        "        # Convert to array index",
        "        insert_idx = before_line - editor.line_start",
        "        ",
        "        # Store old content",
        "        old_content_lines = editor.content.copy()",
        "        ",
        "        # Split content into lines and insert",
        "        insert_lines = content.split('\\n')",
        "        editor.content[insert_idx:insert_idx] = insert_lines",
        "        ",
        "        # Update line_end to reflect new content",
        "        editor.line_end += len(insert_lines)",
        "        ",
        "        # Track edit",
        "        edit = Edit(",
        "            timestamp=time.time(),",
        "            operation='insert',",
        "            target=f\"before line {before_line}\",",
        "            old_content='\\n'.join(old_content_lines),",
        "            new_content='\\n'.join(editor.content)",
        "        )",
        "        editor.edits.append(edit)",
        "        ",
        "        # Write to disk and save state",
        "        self._write_to_disk(editor)",
        "        self.save_state()",
        "        ",
        "        self._add_notification(f\"\u2713 editor.insert() \u2192 {editor.file_path.name} ({len(insert_lines)} lines inserted)\")",
        "        logger.info(f\"Inserted {len(insert_lines)} lines before line {before_line} in {editor.file_path}\")",
        "        return True",
        "    ",
        "    def delete(self, editor_id: str, line_start: int, line_end: int) -> bool:",
        "        \"\"\"",
        "        Delete line range.",
        "        ",
        "        Args:",
        "            editor_id: Editor window ID",
        "            line_start: Start line (1-indexed, relative to editor view)",
        "            line_end: End line (inclusive)",
        "        ",
        "        Returns:",
        "            True if successful",
        "        \"\"\"",
        "        editor = self._get_editor_by_id(editor_id)",
        "        if not editor:",
        "            raise ValueError(f\"Editor not found: {editor_id}\")",
        "        ",
        "        # Validate line numbers",
        "        if line_start < editor.line_start or line_end > editor.line_end:",
        "            raise ValueError(f\"Lines {line_start}-{line_end} out of range ({editor.line_start}-{editor.line_end})\")",
        "        if line_start > line_end:",
        "            raise ValueError(f\"Invalid range: {line_start} > {line_end}\")",
        "        ",
        "        # Convert to array indices",
        "        start_idx = line_start - editor.line_start",
        "        end_idx = line_end - editor.line_start + 1  # +1 because end is inclusive",
        "        ",
        "        # Store old content",
        "        old_content_lines = editor.content.copy()",
        "        ",
        "        # Delete lines",
        "        lines_deleted = end_idx - start_idx",
        "        del editor.content[start_idx:end_idx]",
        "        ",
        "        # Update line_end to reflect deletion",
        "        editor.line_end -= lines_deleted",
        "        ",
        "        # Track edit",
        "        edit = Edit(",
        "            timestamp=time.time(),",
        "            operation='delete',",
        "            target=f\"lines {line_start}-{line_end}\",",
        "            old_content='\\n'.join(old_content_lines),",
        "            new_content='\\n'.join(editor.content)",
        "        )",
        "        editor.edits.append(edit)",
        "        ",
        "        # Write to disk and save state",
        "        self._write_to_disk(editor)",
        "        self.save_state()",
        "        ",
        "        self._add_notification(f\"\u2713 editor.delete() \u2192 {editor.file_path.name} ({lines_deleted} lines deleted)\")",
        "        logger.info(f\"Deleted lines {line_start}-{line_end} from {editor.file_path}\")",
        "        return True",
        "    ",
        "    def replace_lines(self, editor_id: str, line_start: int, line_end: int, content: str) -> bool:",
        "        \"\"\"",
        "        Replace line range with new content.",
        "        ",
        "        Args:",
        "            editor_id: Editor window ID",
        "            line_start: Start line (1-indexed, relative to editor view)",
        "            line_end: End line (inclusive)",
        "            content: New content (can be multi-line string)",
        "        ",
        "        Returns:",
        "            True if successful",
        "        \"\"\"",
        "        editor = self._get_editor_by_id(editor_id)",
        "        if not editor:",
        "            raise ValueError(f\"Editor not found: {editor_id}\")",
        "        ",
        "        # Validate line numbers",
        "        if line_start < editor.line_start or line_end > editor.line_end:",
        "            raise ValueError(f\"Lines {line_start}-{line_end} out of range ({editor.line_start}-{editor.line_end})\")",
        "        if line_start > line_end:",
        "            raise ValueError(f\"Invalid range: {line_start} > {line_end}\")",
        "        ",
        "        # Convert to array indices",
        "        start_idx = line_start - editor.line_start",
        "        end_idx = line_end - editor.line_start + 1  # +1 because end is inclusive",
        "        ",
        "        # Store old content",
        "        old_content_lines = editor.content.copy()",
        "        ",
        "        # Split new content and replace",
        "        new_lines = content.split('\\n')",
        "        lines_removed = end_idx - start_idx",
        "        editor.content[start_idx:end_idx] = new_lines",
        "        ",
        "        # Update line_end to reflect change",
        "        editor.line_end = editor.line_end - lines_removed + len(new_lines)",
        "        ",
        "        # Track edit",
        "        edit = Edit(",
        "            timestamp=time.time(),",
        "            operation='replace_lines',",
        "            target=f\"lines {line_start}-{line_end}\",",
        "            old_content='\\n'.join(old_content_lines),",
        "            new_content='\\n'.join(editor.content)",
        "        )",
        "        editor.edits.append(edit)",
        "        ",
        "        # Write to disk and save state",
        "        self._write_to_disk(editor)",
        "        self.save_state()",
        "        ",
        "        self._add_notification(f\"\u2713 editor.replace_lines() \u2192 {editor.file_path.name} ({len(new_lines)} lines replaced)\")",
        "        logger.info(f\"Replaced lines {line_start}-{line_end} in {editor.file_path}\")",
        "        return True",
        "    ",
        "    def split(self, editor_id: str, line_start: int, line_end: int) -> str:",
        "        \"\"\"",
        "        Create split view of editor.",
        "        ",
        "        Args:",
        "            editor_id: Parent editor window ID",
        "            line_start: Start line for split (1-indexed, relative to editor view)",
        "            line_end: End line for split (inclusive)",
        "        ",
        "        Returns:",
        "            split_id",
        "        \"\"\"",
        "        editor = self._get_editor_by_id(editor_id)",
        "        if not editor:",
        "            raise ValueError(f\"Editor not found: {editor_id}\")",
        "        ",
        "        # Validate line numbers",
        "        if line_start < editor.line_start or line_end > editor.line_end:",
        "            raise ValueError(f\"Lines {line_start}-{line_end} out of range ({editor.line_start}-{editor.line_end})\")",
        "        if line_start > line_end:",
        "            raise ValueError(f\"Invalid range: {line_start} > {line_end}\")",
        "        ",
        "        # Import Split from editor_window",
        "        from nisaba.tui.editor_window import Split",
        "        ",
        "        # Create split",
        "        split = Split(",
        "            parent_id=editor.id,",
        "            line_start=line_start,",
        "            line_end=line_end",
        "        )",
        "        ",
        "        editor.splits[split.id] = split",
        "        self.save_state()",
        "        ",
        "        logger.info(f\"Created split {split.id} for {editor.file_path} lines {line_start}-{line_end}\")",
        "        return split.id",
        "    ",
        "    def resize(self, window_id: str, line_start: int, line_end: int) -> bool:",
        "        \"\"\"",
        "        Resize editor or split window.",
        "        ",
        "        Args:",
        "            window_id: Editor ID or split ID",
        "            line_start: New start line",
        "            line_end: New end line",
        "        ",
        "        Returns:",
        "            True if successful",
        "        \"\"\"",
        "        # Try editor first",
        "        editor = self._get_editor_by_id(window_id)",
        "        if editor:",
        "            # Resizing editor",
        "            if line_start < 1:",
        "                raise ValueError(f\"Invalid line_start: {line_start}\")",
        "            ",
        "            editor.line_start = line_start",
        "            editor.line_end = line_end",
        "            self.save_state()",
        "            logger.info(f\"Resized editor {window_id} to lines {line_start}-{line_end}\")",
        "            return True",
        "        ",
        "        # Try split",
        "        for editor in self.editors.values():",
        "            if window_id in editor.splits:",
        "                split = editor.splits[window_id]",
        "                ",
        "                # Validate against editor bounds",
        "                if line_start < editor.line_start or line_end > editor.line_end:",
        "                    raise ValueError(f\"Lines {line_start}-{line_end} out of range ({editor.line_start}-{editor.line_end})\")",
        "                ",
        "                split.line_start = line_start",
        "                split.line_end = line_end",
        "                self.save_state()",
        "                logger.info(f\"Resized split {window_id} to lines {line_start}-{line_end}\")",
        "                return True",
        "        ",
        "        raise ValueError(f\"Window not found: {window_id}\")",
        "    ",
        "    def close_split(self, split_id: str) -> bool:",
        "        \"\"\"",
        "        Close split view.",
        "        ",
        "        Args:",
        "            split_id: Split ID",
        "        ",
        "        Returns:",
        "            True if successful",
        "        \"\"\"",
        "        for editor in self.editors.values():",
        "            if split_id in editor.splits:",
        "                del editor.splits[split_id]",
        "                self.save_state()",
        "                logger.info(f\"Closed split {split_id}\")",
        "                return True",
        "        ",
        "        return False",
        "    ",
        "    def refresh_all(self) -> List[str]:",
        "        \"\"\"",
        "        Check for external file changes and reload if needed.",
        "        ",
        "        Returns:",
        "            List of notification messages",
        "        \"\"\"",
        "        notifications = []",
        "        ",
        "        for editor in self.editors.values():",
        "            if not editor.file_path.exists():",
        "                notifications.append(f\"\u26a0 File deleted: {editor.file_path}\")",
        "                continue",
        "            ",
        "            current_mtime = editor.file_path.stat().st_mtime",
        "            ",
        "            if current_mtime != editor.last_mtime:",
        "                # File changed externally",
        "                if editor.is_dirty:",
        "                    # Conflict: dirty editor + external change",
        "                    notifications.append(f\"\u26a0 Conflict: {editor.file_path} modified externally with unsaved edits\")",
        "                else:",
        "                    # Clean reload",
        "                    try:",
        "                        content = editor.file_path.read_text().splitlines()",
        "                        # Adjust to current view range",
        "                        if editor.line_end == -1 or editor.line_end > len(content):",
        "                            editor.line_end = len(content)",
        "                        ",
        "                        editor.content = content[editor.line_start-1:editor.line_end]",
        "                        editor.original_content = editor.content.copy()",
        "                        editor.last_mtime = current_mtime",
        "                        self.save_state()",
        "                        ",
        "                        notifications.append(f\"\ud83d\udd04 Reloaded: {editor.file_path}\")",
        "                    except Exception as e:",
        "                        notifications.append(f\"\u2717 Failed to reload {editor.file_path}: {e}\")",
        "        ",
        "        return notifications",
        "    ",
        "    def _add_notification(self, message: str) -> None:",
        "        \"\"\"",
        "        Add notification to notifications file.",
        "        ",
        "        Args:",
        "            message: Notification message",
        "        \"\"\"",
        "        notifications_file = Path(\".nisaba/notifications.md\")",
        "        ",
        "        # Read existing notifications",
        "        if notifications_file.exists():",
        "            content = notifications_file.read_text()",
        "            lines = content.splitlines()",
        "            ",
        "            # Keep only \"Recent activity:\" header and existing notifications",
        "            if lines and lines[0] == \"Recent activity:\":",
        "                existing = lines[1:]",
        "            else:",
        "                existing = []",
        "        else:",
        "            existing = []",
        "        ",
        "        # Add new notification at top",
        "        new_notifications = [message] + existing",
        "        ",
        "        # Keep last 10 notifications",
        "        new_notifications = new_notifications[:10]",
        "        ",
        "        # Write back",
        "        content = \"Recent activity:\\\\n\" + \"\\\\n\".join(new_notifications) + \"\\\\n\"",
        "        notifications_file.write_text(content)",
        "    ",
        "    def close(self, editor_id: str) -> bool:",
        "        \"\"\"",
        "        Close editor window.",
        "        ",
        "        Args:",
        "            editor_id: Editor window ID",
        "        ",
        "        Returns:",
        "            True if successful",
        "        \"\"\"",
        "        editor = self._get_editor_by_id(editor_id)",
        "        if not editor:",
        "            return False",
        "        ",
        "        del self.editors[editor.file_path]",
        "        self.save_state()",
        "        ",
        "        logger.info(f\"Closed editor: {editor.file_path}\")",
        "        return True",
        "    ",
        "    def close_all(self) -> None:",
        "        \"\"\"Close all editor windows.\"\"\"",
        "        self.editors.clear()",
        "        self.save_state()",
        "        logger.info(\"Closed all editors\")",
        "    ",
        "    def status(self) -> Dict[str, Any]:",
        "        \"\"\"",
        "        Get status summary.",
        "        ",
        "        Returns:",
        "            Dict with editor count, total lines, and editor list",
        "        \"\"\"",
        "        total_lines = sum(len(editor.content) for editor in self.editors.values())",
        "        ",
        "        return {",
        "            \"editor_count\": len(self.editors),",
        "            \"total_lines\": total_lines,",
        "            \"editors\": [",
        "                {",
        "                    \"id\": editor.id,",
        "                    \"file\": str(editor.file_path),",
        "                    \"lines\": f\"{editor.line_start}-{editor.line_end}\",",
        "                    \"line_count\": len(editor.content),",
        "                    \"edits\": len(editor.edits),",
        "                    \"dirty\": editor.is_dirty",
        "                }",
        "                for editor in self.editors.values()",
        "            ]",
        "        }",
        "    ",
        "    def render(self) -> str:",
        "        \"\"\"",
        "        Render all editors and splits to markdown with diff markers.",
        "        ",
        "        Returns:",
        "            Markdown string",
        "        \"\"\"",
        "        # Check for external changes first",
        "        refresh_notifications = self.refresh_all()",
        "        for notif in refresh_notifications:",
        "            self._add_notification(notif)",
        "        ",
        "        if not self.editors:",
        "            return \"\"",
        "        ",
        "        lines = []",
        "        ",
        "        for editor in self.editors.values():",
        "            # Render main editor",
        "            lines.append(f\"---EDITOR_{editor.id}\")",
        "            lines.append(f\"**file**: {editor.file_path}\")",
        "            lines.append(f\"**lines**: {editor.line_start}-{editor.line_end} ({len(editor.content)} lines)\")",
        "            ",
        "            if editor.splits:",
        "                lines.append(f\"**splits**: {len(editor.splits)}\")",
        "            ",
        "            if editor.is_dirty:",
        "                lines.append(f\"**status**: modified \u270e\")",
        "                lines.append(f\"**edits**: {len(editor.edits)} (last: {self._format_time_ago(editor.edits[-1].timestamp)})\")",
        "            ",
        "            lines.append(\"\")",
        "            ",
        "            # Render content with diff markers if modified",
        "            if editor.is_dirty:",
        "                diff_lines = self._generate_inline_diff(editor)",
        "                lines.extend(diff_lines)",
        "            else:",
        "                for i, line in enumerate(editor.content):",
        "                    line_num = editor.line_start + i",
        "                    lines.append(f\"{line_num}: {line}\")",
        "            ",
        "            lines.append(f\"---EDITOR_{editor.id}_END\")",
        "            lines.append(\"\")",
        "            ",
        "            # Render splits",
        "            for split in editor.splits.values():",
        "                lines.append(f\"---EDITOR_SPLIT_{split.id}\")",
        "                lines.append(f\"**parent**: {split.parent_id}\")",
        "                lines.append(f\"**file**: {editor.file_path}\")",
        "                lines.append(f\"**lines**: {split.line_start}-{split.line_end}\")",
        "                lines.append(\"\")",
        "                ",
        "                # Get content slice from editor",
        "                start_idx = split.line_start - editor.line_start",
        "                end_idx = split.line_end - editor.line_start + 1",
        "                split_content = editor.content[start_idx:end_idx]",
        "                ",
        "                for i, line in enumerate(split_content):",
        "                    line_num = split.line_start + i",
        "                    lines.append(f\"{line_num}: {line}\")",
        "                ",
        "                lines.append(f\"---EDITOR_SPLIT_{split.id}_END\")",
        "                lines.append(\"\")",
        "        ",
        "        return '\\n'.join(lines)",
        "    ",
        "    def save_state(self) -> None:",
        "        \"\"\"Save editor state to JSON.\"\"\"",
        "        state = {",
        "            \"editors\": {",
        "                str(file_path): editor.to_dict()",
        "                for file_path, editor in self.editors.items()",
        "            }",
        "        }",
        "        ",
        "        self.state_file.parent.mkdir(parents=True, exist_ok=True)",
        "        self.state_file.write_text(json.dumps(state, indent=2), encoding='utf-8')",
        "        logger.debug(f\"Saved {len(self.editors)} editors to state file\")",
        "    ",
        "    def load_state(self) -> None:",
        "        \"\"\"Restore editors from JSON.\"\"\"",
        "        if not self.state_file.exists():",
        "            logger.debug(\"No state file found, starting with empty editors\")",
        "            return",
        "        ",
        "        try:",
        "            state = json.loads(self.state_file.read_text(encoding='utf-8'))",
        "            ",
        "            for file_path_str, editor_data in state.get(\"editors\", {}).items():",
        "                file_path = Path(file_path_str)",
        "                ",
        "                # Re-read content from file (handles external changes)",
        "                try:",
        "                    with open(file_path, 'r', encoding='utf-8') as f:",
        "                        all_lines = f.readlines()",
        "                    ",
        "                    all_lines = [line.rstrip('\\n') for line in all_lines]",
        "                    ",
        "                    # Extract range",
        "                    start = editor_data[\"line_start\"]",
        "                    end = editor_data[\"line_end\"]",
        "                    ",
        "                    if end == -1 or end > len(all_lines):",
        "                        content = all_lines[start-1:]",
        "                    else:",
        "                        content = all_lines[start-1:end]",
        "                    ",
        "                    # Restore editor",
        "                    editor = EditorWindow.from_dict(editor_data, content)",
        "                    self.editors[file_path] = editor",
        "                    ",
        "                except Exception as e:",
        "                    logger.warning(f\"Skipping editor {file_path}: {e}\")",
        "                    continue",
        "            ",
        "            logger.info(f\"Restored {len(self.editors)} editors from state file\")",
        "        except Exception as e:",
        "            logger.warning(f\"Failed to load state file: {e}\")",
        "    ",
        "    def _get_editor_by_id(self, editor_id: str) -> Optional[EditorWindow]:",
        "        \"\"\"Find editor by ID.\"\"\"",
        "        for editor in self.editors.values():",
        "            if editor.id == editor_id:",
        "                return editor",
        "        return None",
        "    ",
        "    def _write_to_disk(self, editor: EditorWindow) -> None:",
        "        \"\"\"Write editor content back to file.\"\"\"",
        "        try:",
        "            # Read full file",
        "            with open(editor.file_path, 'r', encoding='utf-8') as f:",
        "                all_lines = f.readlines()",
        "            ",
        "            all_lines = [line.rstrip('\\n') for line in all_lines]",
        "            ",
        "            # Replace the range",
        "            start_idx = editor.line_start - 1",
        "            end_idx = editor.line_end",
        "            ",
        "            new_lines = (",
        "                all_lines[:start_idx] +",
        "                editor.content +",
        "                all_lines[end_idx:]",
        "            )",
        "            ",
        "            # Write back",
        "            editor.file_path.write_text('\\n'.join(new_lines) + '\\n', encoding='utf-8')",
        "            ",
        "            # Update mtime",
        "            editor.last_mtime = editor.file_path.stat().st_mtime",
        "            ",
        "        except Exception as e:",
        "            logger.error(f\"Failed to write {editor.file_path}: {e}\", exc_info=True)",
        "            raise",
        "    ",
        "    def _generate_inline_diff(self, editor: EditorWindow) -> List[str]:",
        "        \"\"\"Generate diff with +/- markers inline.\"\"\"",
        "        diff = difflib.ndiff(editor.original_content, editor.content)",
        "        ",
        "        lines = []",
        "        line_num = editor.line_start",
        "        ",
        "        for d in diff:",
        "            prefix = d[0]",
        "            content = d[2:]",
        "            ",
        "            if prefix == ' ':  # Unchanged",
        "                lines.append(f\"{line_num}: {content}\")",
        "                line_num += 1",
        "            elif prefix == '-':  # Removed",
        "                lines.append(f\"{line_num}: -{content}\")",
        "            elif prefix == '+':  # Added",
        "                lines.append(f\"{line_num}: +{content}\")",
        "                line_num += 1",
        "        ",
        "        return lines",
        "    ",
        "    def _format_time_ago(self, timestamp: float) -> str:",
        "        \"\"\"Format timestamp as relative time.\"\"\"",
        "        seconds = time.time() - timestamp",
        "        ",
        "        if seconds < 60:",
        "            return f\"{int(seconds)}s ago\"",
        "        elif seconds < 3600:",
        "            return f\"{int(seconds / 60)}m ago\"",
        "        elif seconds < 86400:",
        "            return f\"{int(seconds / 3600)}h ago\"",
        "        else:",
        "            return f\"{int(seconds / 86400)}d ago\""
      ],
      "metadata": {
        "total_lines": 737
      },
      "opened_at": 1762532795.766431,
      "file_path": "src/nisaba/tui/editor_manager.py",
      "start_line": 1,
      "end_line": 737,
      "command": "",
      "exit_code": 0,
      "pattern": "",
      "glob_pattern": ""
    },
    "05ec80e5-59b7-4598-873a-2a74670d091d": {
      "id": "05ec80e5-59b7-4598-873a-2a74670d091d",
      "window_type": "read_result",
      "content": [
        "\"\"\"Editor window dataclasses for persistent code editing.\"\"\"",
        "",
        "import time",
        "from dataclasses import dataclass, field",
        "from pathlib import Path",
        "from typing import List, Any, Dict",
        "from uuid import uuid4",
        "",
        "",
        "@dataclass",
        "class Edit:",
        "    \"\"\"Record of a single edit operation.\"\"\"",
        "    timestamp: float",
        "    operation: str  # 'replace', 'replace_lines', 'insert', 'delete'",
        "    target: str  # old string or line range description",
        "    old_content: str",
        "    new_content: str",
        "",
        "",
        "",
        "@dataclass",
        "class Split:",
        "    \"\"\"Split view of an editor window.\"\"\"",
        "    id: str = field(default_factory=lambda: str(uuid4()))",
        "    parent_id: str = \"\"",
        "    line_start: int = 1",
        "    line_end: int = 1",
        "    opened_at: float = field(default_factory=lambda: time.time())",
        "    ",
        "    def to_dict(self) -> Dict[str, Any]:",
        "        \"\"\"Serialize for JSON.\"\"\"",
        "        return {",
        "            \"id\": self.id,",
        "            \"parent_id\": self.parent_id,",
        "            \"line_start\": self.line_start,",
        "            \"line_end\": self.line_end,",
        "            \"opened_at\": self.opened_at",
        "        }",
        "    ",
        "    @classmethod",
        "    def from_dict(cls, data: Dict[str, Any]) -> \"Split\":",
        "        \"\"\"Restore from JSON.\"\"\"",
        "        return cls(",
        "            id=data[\"id\"],",
        "            parent_id=data[\"parent_id\"],",
        "            line_start=data[\"line_start\"],",
        "            line_end=data[\"line_end\"],",
        "            opened_at=data.get(\"opened_at\", time.time())",
        "        )",
        "",
        "",
        "@dataclass",
        "class EditorWindow:",
        "    \"\"\"",
        "    Represents an open editor window with change tracking.",
        "    ",
        "    One editor per file - no duplicates allowed.",
        "    \"\"\"",
        "    id: str = field(default_factory=lambda: str(uuid4()))",
        "    file_path: Path = field(default_factory=Path)",
        "    line_start: int = 1",
        "    line_end: int = -1",
        "    content: List[str] = field(default_factory=list)",
        "    original_content: List[str] = field(default_factory=list)",
        "    edits: List[Edit] = field(default_factory=list)",
        "    splits: Dict[str, Split] = field(default_factory=dict)",
        "    last_mtime: float = 0.0",
        "    opened_at: float = field(default_factory=lambda: time.time())",
        "    ",
        "    @property",
        "    def is_dirty(self) -> bool:",
        "        \"\"\"Check if editor has unsaved changes.\"\"\"",
        "        return len(self.edits) > 0",
        "    ",
        "    def to_dict(self) -> Dict[str, Any]:",
        "        \"\"\"Serialize for JSON persistence.\"\"\"",
        "        return {",
        "            \"id\": self.id,",
        "            \"file_path\": str(self.file_path),",
        "            \"line_start\": self.line_start,",
        "            \"line_end\": self.line_end,",
        "            \"opened_at\": self.opened_at,",
        "            \"last_mtime\": self.last_mtime,",
        "            \"edit_count\": len(self.edits),",
        "            \"splits\": {sid: split.to_dict() for sid, split in self.splits.items()}",
        "        }",
        "    ",
        "    @classmethod",
        "    def from_dict(cls, data: Dict[str, Any], content: List[str]) -> \"EditorWindow\":",
        "        \"\"\"Restore from JSON (content re-read from file).\"\"\"",
        "        # Restore splits",
        "        splits = {}",
        "        for sid, split_data in data.get(\"splits\", {}).items():",
        "            splits[sid] = Split.from_dict(split_data)",
        "        ",
        "        return cls(",
        "            id=data[\"id\"],",
        "            file_path=Path(data[\"file_path\"]),",
        "            line_start=data[\"line_start\"],",
        "            line_end=data[\"line_end\"],",
        "            content=content,",
        "            original_content=content.copy(),",
        "            edits=[],  # Fresh start on reload",
        "            splits=splits,",
        "            last_mtime=data.get(\"last_mtime\", 0.0),",
        "            opened_at=data.get(\"opened_at\", time.time())",
        "        )"
      ],
      "metadata": {
        "total_lines": 107
      },
      "opened_at": 1762532795.8111126,
      "file_path": "src/nisaba/tui/editor_window.py",
      "start_line": 1,
      "end_line": 107,
      "command": "",
      "exit_code": 0,
      "pattern": "",
      "glob_pattern": ""
    }
  }
}