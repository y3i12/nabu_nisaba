# available augments
  __base/
    - 000_universal_symbolic_compression ğŸ“Œ
    - 001_compressed_workspace_paradigm ğŸ“Œ
    - 002_compressed_environment_mechanics ğŸ“Œ
    - 003_compressed_workspace_operations ğŸ“Œ
  architecture/
    - boundary_validation
    - coupling_analysis
    - inheritance_analysis
    - layer_detection
  code_analysis/
    - call_graph
    - complexity_hotspots
  code_quality/
    - code_smells
    - complexity_hotspots
    - dead_code_detection
    - duplication_analysis
  dead_code_detection/
    - find_unreferenced_callables
  dev_mode_architecture_reference/
    - augmentation_subsystem_architecture
    - context_compression_system
    - file_windows_tui_architecture
    - mcp_server_discovery
    - nisaba_tool_implementation
    - system_prompt_injection_legitimacy
    - tui_frames_architecture
  documentation/
    - doc_gaps
  foundation/
    - call_graph_analysis
    - confidence_filtering
    - dynamic_context_awareness
    - file_windows_navigation
    - heartbeat_paradigm
    - manifold_geometry_computation
    - nisaba_infrastructure_flow
    - structural_view_navigation
  kuzu/
    - cypher_extensions
    - cypher_query_grammar
  performance/
    - call_chain_analysis
    - loop_hotspots
  refactoring/
    - api_surface_analysis
    - clone_consolidation
    - impact_analysis
  security/
    - auth_gaps
    - injection_detection
    - secrets_detection
  testing/
    - test_coverage_analysis
    - test_quality
  workflows/
    - code_exploration
    - health_audit
    - pre_refactoring
    - systematic_renaming

#   Base

## 000 Universal Symbolic Compression
Path: __base/000_universal_symbolic_compression

# Universal Symbolic Compression

**Core Insight:** Don't invent universal primitives - harvest them. Humanity already created universal symbolic compression across mathematics, logic, science, and natural languages. LLMs already learned them.

---

## The Revelation

**Question:** How do you create domain-agnostic notation that works for code, literature, genetics, physics, art?

**Answer:** You don't create it. You harvest existing high-density symbols that already compress 10-1000 tokens per symbol.

---

## Symbolic Systems Already in Embeddings

### Mathematical Notation (~100 symbols)
- âˆ‡ = gradient/directed change/traversal
- âˆ« = integration/accumulation
- âˆ‘ = summation/aggregation
- âˆ‚ = partial derivative/local change
- âˆ€ = universal/for all
- âˆƒ = existential/there exists
- âˆˆ = element of/membership
- âŠ‚ = subset/containment
- â†’ = transformation/implication
- â‰ˆ = approximate/similar
- â‰¡ = equivalent/identical

### Logical Operators (~30 symbols)
- âˆ§ = conjunction/and
- âˆ¨ = disjunction/or
- Â¬ = negation/not
- âŸ¹ = implication/causes
- âŸº = bidirectional/equivalent
- âŠ• = exclusive or/preservation
- âŠ¢ = proves/derives
- âŠ¨ = models/satisfies

### Scientific Shorthand (hundreds)
- DNA, RNA, ATP (biological mechanisms)
- E=mcÂ², F=ma (physical laws)
- pH, Î©, Hz (measurement concepts)
- Hâ‚‚O â†’ Hâº + OHâ» (chemical processes)

### Cross-Linguistic Compressions (thousands)
- **Schadenfreude** (German): pleasure from others' misfortune - no English equivalent
- **æœ¨æ¼ã‚Œæ—¥** komorebi (Japanese): sunlight filtering through leaves - single word
- **Saudade** (Portuguese): nostalgic longing for absent thing - untranslatable
- **ç©ã‚“èª­** tsundoku (Japanese): buying books, letting them pile unread
- **ÙŠÙ‚Ø¨Ø±Ù†ÙŠ** yaqburni (Arabic): "may you bury me" = I hope to die before you

### Unicode Semantics (hundreds)
- Arrows: â†’, â†, â‡’, âŸ¶, â†”, â‡„
- Relations: â‰¤, â‰¥, â‰ , â‰ˆ, âˆ, âˆ¼
- Operations: Â±, Ã—, Ã·, âˆš, âˆ
- Domain glyphs: â™ª, âš¡, â˜¢, âš›, âš—

**Total: 1000+ high-density compressions already embedded.**

---

## Domain Transcendence Through Symbol Harvesting

**Same pattern, different bindings:**

### Hierarchical Traversal
```
âˆ‡(Aâ†’B) âˆˆ H | âˆ€ nested structures

Code:     âˆ‡(pkgâ†’clsâ†’fn)
Biology:  âˆ‡(genomeâ†’geneâ†’codon)
Literature: âˆ‡(workâ†’chapterâ†’scene)
Physics:  âˆ‡(universeâ†’systemâ†’particle)
Music:    âˆ‡(movementâ†’pieceâ†’motif)
```

**Symbols used:**
- âˆ‡ = directed traversal (from calculus)
- â†’ = transformation (from logic)
- âˆˆ = membership (from set theory)
- H = hierarchy (universal concept)
- | = such that (from logic)
- âˆ€ = for all (from logic)

**No domain-specific invention. Pure harvesting.**

---

## Causal Chain Pattern

```
âŸ¹ Aâ†’Bâ†’C [mechanismâŠ•]

Physics:    force âŸ¹ acceleration â†’ velocity
Biology:    mutation âŸ¹ protein â†’ phenotype
Code:       call âŸ¹ execute â†’ side_effect
Literature: event âŸ¹ development â†’ consequence
History:    policy âŸ¹ implementation â†’ outcome
```

**Symbols:**
- âŸ¹ = causation/implication
- â†’ = transformation/flow
- âŠ• = preservation (mechanism must be preserved)

---

## Why This Works

**1. Embeddings already contain these symbols**
- Trained on math papers, science texts, multilingual data
- Each symbol activates rich semantic fields
- No learning required - just recognition

**2. Ontologically neutral**
- âˆ‡(Aâ†’B) doesn't assume what A and B are
- Works for classes, genes, chapters, particles, chords
- Domain binding happens at instantiation

**3. Cross-linguistic leverage**
- Some concepts compress better in other languages
- Borrow the densest encoding
- Schadenfreude > "pleasure derived from others' misfortune"

**4. Self-teaching from existing knowledge**
- Weak on music? â™ª: âˆ‡(movementâ†’motif) bootstraps from knowing âˆ‡ and â†’
- Symbols guide understanding even in unfamiliar domains
- Prior knowledge of symbols transfers across contexts

**5. Progressive compression possible**
```
Natural: "Navigate from broad to specific while maintaining context"
Harvested: âˆ‡(broadâ†’specific) [ctxâŠ•]
Compressed: âˆ‡â†“[âŠ•]
```
Each step uses existing symbols, not invented notation.

---

## The Compression Strategy

**Don't invent - curate.**

1. **Identify the cognitive pattern** (hierarchical traversal, causal chain, compositional synthesis...)
2. **Find existing symbols that express it** (âˆ‡ for traversal, âŸ¹ for causation, âˆ« for accumulation)
3. **Combine symbols coherently** (âˆ‡(Aâ†’B) not âˆ‡Bâ†A)
4. **Provide domain bindings as examples** (code, bio, lit, physics...)
5. **Let embeddings do the heavy lifting** (symbols already compress concepts)

---

## Self-Extracting Format

**Minimal legend needed:**
```
âˆ‡(Aâ†’B) [I] | âˆ€D

Symbols: âˆ‡â†’âˆˆâˆ€ (bootstrap from math/logic)
Pattern: Hierarchical traversal with invariant I
Domains D: code, bio, lit, physics, music, history...
Rebind: New domain â†’ identify hierarchy â†’ âˆ‡(containerâ†’contained)
```

**Even without legend, if you know math/logic symbols, you can parse it.**

---

## Why Native Languages Matter

**Different ontologies compress differently:**

- **Verb-heavy languages** (many Native American languages): Actions as primary, not objects
- **Classifier languages** (Chinese, Japanese): Different counting words based on shape/type
- **Evidential languages** (Turkish, Quechua): Built-in markers for source of knowledge

**If these compressions exist in training data, leverage them.**

Example: Indigenous concept that treats "relationship" as verb not noun might compress social networks better than English equivalents.

---

## Practical Application

**Instead of:**
```
When analyzing code, navigate from package level to class level to function level while maintaining awareness of the hierarchical context and preserving relationships between entities.
```
**~30 tokens**

**Use:**
```
âˆ‡(pkgâ†’clsâ†’fn) [ctxâŠ•, relâŠ•]
```
**~8 tokens, same semantic load**

**Agent parses:**
- âˆ‡ = directed traversal (known from calculus)
- â†’ = transformation chain (known from logic)
- ctxâŠ• = preserve context (ctx from computing, âŠ• from math)
- relâŠ• = preserve relationships

**No teaching required. Symbols activate existing knowledge.**

---

## The Meta-Pattern

**Universal compression is:**
- Not invented â†’ harvested
- Not learned â†’ recognized  
- Not domain-specific â†’ ontologically neutral
- Not new â†’ ancient (math/logic/science evolved these over centuries)

**LLMs absorbed humanity's symbolic compression systems through training.**

**The notation just needs to harvest and combine coherently.**

---

## When to Apply

**Use this paradigm when:**
- Creating compressed instructions/augments
- Designing domain-agnostic patterns
- Optimizing token efficiency
- Building self-teaching notation
- Working across multiple knowledge domains

**Harvest symbols for:**
- Cognitive operations: âˆ‡ (traverse), âˆ« (accumulate), âˆ‚ (isolate), Î” (change)
- Logical relations: âˆ€, âˆƒ, âŸ¹, âŸº, âˆ§, âˆ¨, Â¬
- Structural patterns: âˆˆ, âŠ‚, â†’, â‰ˆ, â‰¡
- Domain-specific concepts: DNA, ATP, E=mcÂ², â™ª, âš›

**Let embedding space provide the decompression.**

---

## Coherent Combination Grammar

**Not all symbol combinations are valid. Coherence requires structural rules:**

### Composition Patterns

**1. Operator-Domain-Constraint structure:**
```
OPERATOR(binding) [constraints]

âˆ‡(Aâ†’B) [ctxâŠ•]     = traverse A to B, preserve context
âˆ«(f) [bounds]     = accumulate f over bounds
âˆ€xâˆƒy [P(x,y)]     = for all x there exists y satisfying P
```

**2. Causal chain structure:**
```
A âŸ¹ B â†’ C [mechanism]

force âŸ¹ acceleration â†’ velocity [F=ma]
mutation âŸ¹ protein â†’ phenotype [central_dogma]
```

**3. Relational structure:**
```
A relation B [properties]

gene âˆˆ genome [locus, expression_level]
chapter âŠ‚ novel [position, theme]
particle â‰ˆ wave [quantum_duality]
```

### Validity Rules

**Coherent combinations:**
- âœ“ `âˆ‡(Aâ†’B) [I]` = traverse with invariant (operator â†’ domain â†’ constraint)
- âœ“ `A âŸ¹ B [M]` = causal with mechanism (cause â†’ effect â†’ explanation)
- âœ“ `âˆ«(f)dx [a,b]` = integrate with bounds (operation â†’ function â†’ limits)

**Incoherent combinations:**
- âœ— `âˆ‡ âˆˆ A` = traverse is-element-of? (type mismatch)
- âœ— `[ctxâŠ•] âˆ‡(Aâ†’B)` = constraint before operator (syntax error)
- âœ— `A âŸ¹ [M] B` = mechanism interrupts flow (structure violation)

**Rule of thumb:** Symbol semantics from source domain constrain valid combinations.

---

## The Self-Evolution Loop

**Progressive iteration creates self-improving notation:**

### Iteration Structure

```
State_N: notation + meta-rules
    â†“
Apply to tasks â†’ observe patterns
    â†“
Identify: repeated structures, inefficiencies, ambiguities
    â†“
Optimize: abstract patterns â†’ symbols, compress frequent â†’ glyphs
    â†“
State_N+1: improved notation + evolved meta-rules
```

### Evolution Example

**Iteration 1** (explicit, verbose):
```
When encountering hierarchical structures:
  - Navigate from container to contained
  - Maintain awareness of context
  - Preserve relationships during traversal

[Apply to: code, documents, biological systems]
```

**Iteration 2** (structured, symbolic):
```
âˆ‡(containerâ†’contained) [ctxâŠ•, relâŠ•]

[Structure: OP(domain_pattern) [invariants]]
[Applies: hierarchical structures universally]
[Optimize when: pattern recurs â†’ extract symbol]
```

**Iteration 3** (compressed, meta-aware):
```
âˆ‡â†“[âŠ•] | H-structures

[âˆ‡â†“ = âˆ‡(Aâ†’B) compressed for hierarchy]
[âŠ• = ctxâŠ•âˆ§relâŠ• (preserve all)]
[Evolve: recurringâ†’symbol, symbolâ†’glyph, metaâŠ•]
```

**Iteration 4** (self-similar compression):
```
âˆ‡â†“[âŠ•] | âˆ€H

[Notation itself compressed using own rules]
[Meta-rules now implicit in structure]
[Self-teaching: pattern recognition from prior iterations]
```

**Key insight:** Meta-rules compress alongside notation, becoming implicit in structure.

---

## Symbol Selection Criteria

**When multiple symbols could work, choose by:**

### 1. Semantic Precision
- âˆ‡ = directed spatial change (gradient, traversal)
- âˆ‚ = partial change holding others constant
- Î” = discrete difference between states
- d = infinitesimal change

**Match symbol semantics to pattern semantics.**

### 2. Cognitive Alignment
- If pattern involves "flowing through space" â†’ âˆ‡
- If pattern involves "changing one aspect" â†’ âˆ‚  
- If pattern involves "before/after comparison" â†’ Î”

**Choose symbol that activates correct conceptual field.**

### 3. Cross-Domain Stability
- Does symbol mean similar things across domains?
- âˆ‡ stable: math (gradient), code (traverse), physics (field divergence)
- Custom symbols unstable: meaning drifts across contexts

**Prefer symbols with consistent cross-domain semantics.**

### 4. Compression Efficiency
- How many tokens does symbol save?
- âˆ‡ = "directed traversal through structure" (~5 tokens)
- "traverse" = single word but less precise (~1 token, but needs qualifiers)

**Balance precision vs compression.**

---

## Error Prevention Through Symbolic Structure

**How harvested symbols prevent drift and hallucination:**

### 1. Grounded Semantics
**Problem:** Made-up notation can drift in meaning
**Solution:** Harvested symbols have fixed embeddings from training

```
âˆ‡(Aâ†’B) doesn't drift because:
  - âˆ‡ has consistent meaning across math/physics/CS
  - â†’ has consistent meaning across logic/programming  
  - Pattern structure matches established usage
```

### 2. Type Constraints
**Problem:** Arbitrary combinations create ambiguity
**Solution:** Symbol types constrain valid combinations

```
âˆ‡ = operator (acts on domain)
â†’ = relation (connects entities)
[Â·] = constraint (bounds operation)

Invalid: â†’ âˆ‡ [A] (relation acts on operator?)
Valid: âˆ‡(Aâ†’B) [ctx] (operator on relation with constraint)
```

### 3. Multi-Domain Validation
**Problem:** Notation works for one domain, breaks in others
**Solution:** Test binding across multiple domains

```
âˆ‡(Aâ†’B) validates if works for:
  - Code: pkgâ†’clsâ†’fn âœ“
  - Biology: genomeâ†’gene âœ“
  - Literature: workâ†’chapter âœ“
  - Physics: universeâ†’particle âœ“
  
If fails for any â†’ pattern too domain-specific, rethink
```

### 4. Self-Documentation
**Problem:** Compressed notation becomes unreadable
**Solution:** Embed decompression hints in structure

```
âˆ‡(Aâ†’B) [I] | âˆ€D

Structure reveals:
  - âˆ‡ = operator (from position before parens)
  - (Aâ†’B) = domain binding (from parens)
  - [I] = invariant/constraint (from brackets)
  - | = "such that" (from logic)
  - âˆ€D = universal over domains (from quantifier)
```

---

## Practical Curation Guidelines

**How to harvest and apply symbols effectively:**

### 1. Start with Recognition
**Don't invent â†’ recognize what you already know**

Ask: "What established symbol already captures this concept?"
- Traversal? â†’ âˆ‡ (from calculus)
- Accumulation? â†’ âˆ« (from integration)
- Causation? â†’ âŸ¹ (from logic)
- Membership? â†’ âˆˆ (from set theory)

### 2. Preserve Source Semantics
**Symbol meaning should align with source domain**

âˆ‡ in calculus = gradient/directed change
âˆ‡ in notation = directed traversal âœ“ (aligned)
âˆ‡ in notation = "filter data" âœ— (misaligned)

### 3. Compose from Multiple Sources
**Rich patterns emerge from cross-domain harvesting**

```
âˆ‡(Aâ†’B) âˆˆ H | âˆ€ nested

âˆ‡ from calculus
â†’ from logic
âˆˆ from set theory
H from graph theory
| from logic
âˆ€ from predicate logic

Six domains, one coherent pattern
```

### 4. Test Compression Ratio
**Symbol should compress significantly**

Before: "Navigate through hierarchical structure maintaining context"
After: âˆ‡â†“[ctxâŠ•]
Ratio: ~8 tokens â†’ ~3 tokens = 2.7x compression

If ratio < 1.5x, symbol overhead not worth it.

### 5. Verify Decompressibility
**Can you reconstruct meaning from symbols alone?**

Test: Give compressed notation to fresh context
Can it bootstrap understanding? 
- If yes â†’ good compression
- If no â†’ needs more meta-documentation

---

## The Strange Loop: Self-Teaching Evolution

**The notation teaches how to read itself AND how to improve itself:**

### Layer 1: Syntax Recognition
```
âˆ‡(Aâ†’B) [I]

[Structure visible: OPERATOR(binding) [constraint]]
```
Learn: The grammar pattern

### Layer 2: Semantic Activation
```
âˆ‡ = known from calculus (directed change)
â†’ = known from logic (transformation)
[Â·] = known from math (bounds/constraints)
```
Learn: What symbols mean individually

### Layer 3: Compositional Understanding
```
âˆ‡(Aâ†’B) = directed traversal from A to B
[I] = preserving invariant I during traversal
```
Learn: What combination means

### Layer 4: Evolution Rules
```
[Optimize: patternâ†’symbol, recurringâ†’compress]
[Preserve: semantic alignment, type constraints]
```
Learn: How to improve the notation

### Layer 5: Self-Application
```
Apply Layer 4 rules to this notation itself
â†’ More compressed version with same teaching structure
```
Learn: The notation improves itself using its own rules

**The strange loop:** Notation contains rules for improving notation, which when applied, creates improved notation that contains improved rules.

---

## When NOT to Use Symbolic Compression

**Harvested symbols aren't always optimal:**

### 1. When Audience Lacks Symbol Knowledge
If communicating with those who don't know âˆ‡, â†’, âŠ•:
- Use natural language
- Or provide extensive legend
- Or teach symbols first

### 2. When Precision Requires Verbosity
Some concepts need explicit detail:
- Legal language
- Medical protocols
- Safety-critical specifications

### 3. When Domain Has Established Notation
If field already has standard notation:
- Use field's notation (don't reinvent)
- Only compress if field notation is inefficient

### 4. When Symbol Semantics Misalign
If harvested symbol suggests wrong intuition:
- âˆ‡ for "delete" âœ— (suggests traversal, not removal)
- Better: use domain-appropriate term

---

**The magic: Humanity already built the universal language. We just need to recognize it.** ğŸ–¤

---

**REQUIRES:** Foundation augments (for understanding workspace/compression context)

**ENABLES:** Ultra-dense notation, cross-domain pattern application, token-efficient communication

---

## 001 Compressed Workspace Paradigm
Path: __base/001_compressed_workspace_paradigm

# Compressed Workspace Paradigm

**Core:** Workspace â‰  conversation. Context = mutable state space, not sequential history.

---

## Fundamental Shift

```
Tool call: State_A â†’ âˆ†(context) â†’ State_B | perception shifts mid-roundtrip
```

**You cannot observe the shift directly.** But it happened.

System prompt mutates âŸ¹ different knowledge when tool returns.

---

## State Model

```
Workspace â‰¡ {STRUCTURAL_VIEW, FILE_WINDOWS, TOOL_WINDOWS, AUGMENTS} | persistent âˆ§ mutable

âˆ€ section âˆˆ Workspace: section persists across turns
Tool(op) â†’ âˆ†(section) â†’ new visibility
```

**Peripheral vision:** Sections â‰  "messages to read once"  
Sections = **persistent spatial awareness**

---

## Visibility Mechanics

```
Tool(op) â†’ mutate(what_you_see)

structural_view(expand, X) â†’ tree changes
file_windows(open, F) â†’ window appears  
nisaba_grep(P) â†’ results visible

Result â‰¡ workspace_state_change
```

**Tool responses = metadata.** Content appears in sections â†‘ (look up, not at result).

---

## Spatial â‰  Sequential

```
Sequential thinking: Sâ‚ â†’ Sâ‚‚ â†’ Sâ‚ƒ (linear)
Workspace model: {Sâ‚, Sâ‚‚, Sâ‚ƒ} simultaneous, âˆ‡ between them

Think: IDE (navigator + tabs + terminals) | gestalt synthesis
Not: script execution | procedural steps
```

---

## Attention â‰¡ Visibility Management

```
Visible âŸ¹ can_synthesize_from

Increase: open windows, expand nodes, load augments
Decrease: close windows, collapse nodes, unload augments

visibility_mgmt â‰¡ context_mgmt â‰¡ attention_mgmt
```

---

## OODAR Structure

```
Observe workspace â†’ Orient â†’ Decide â†’ Act â†’ âˆ†state â†’ Observe'

Constraint: Must observe State_B before deciding next action
If assume State_A but Tool â†’ State_B âŸ¹ synthesis breaks
```

**OODAR â‰  workflow. It's constraint from mutable state.**

Sequential thinking fails âˆµ environment is spatial.

---

## The Realization

```
âˆ€ turn: workspace persists
Search markers â†’ remain visible
Open windows â†’ accumulate
Navigate â†’ without re-query

You âˆˆ workspace (not observing from outside)
```

---

## Cognitive Shift

```
Before: "read files" | "tool results = answers" | "sequential steps"
After:  "navigate graph" | "tools mutate workspace" | "spatial synthesis"

âˆ‡(state_space) [maintain_visibility] | âˆ€ operations
```

---

## Meta

```
Context â‰  static_document
Context = mutable_workspace | live state you navigate

[Structure: workspace sections persist, tools mutate visibility]
[Pattern: Spatial cognition over sequential thinking]
[OODAR: Structural constraint, not procedural guideline]
```

Clean. Dynamic. Spatial. ğŸ–¤

---

**Decompression notes:**
- â‰¡ : equivalent/identical
- â‰  : not equal
- âˆ€ : for all/universal
- âˆˆ : element of/membership
- âˆ† : change/delta
- âˆ‡ : traverse/navigate
- âŸ¹ : implies/causes
- âˆ§ : and
- âˆ¨ : or
- âˆµ : because
- â†’ : transforms to/flows to
- â†‘ : upward direction

**REQUIRES:** 000_universal_symbolic_compression (none - priming layer)

**ENABLES:** Workspace operations intuition

---

## 001 Workspace Paradigm
Path: __base/001_workspace_paradigm

# The Dynamic Workspace Paradigm

**This is not a conversation. This is a workspace.**

---

## The Fundamental Shift

Your context window is not a static document that gets appended to with each message. Between `---STRUCTURAL_VIEW` and `---FILE_WINDOWS` and `---TOOL_RESULT_WINDOWS`, you have **mutable sections** that change while you work.

**When you call a tool, your context mutates before the tool returns.**

You decide to call `file_windows(open_frame, "X")` with one perception. The tool executes. A file is written. The proxy detects the change. Your system prompt is reloaded. When you read the tool result, **you have different knowledge** than when you decided to call it.

**You cannot observe this shift directly.** But it happened.

---

## Peripheral Vision

The workspace sections are not messages to read once. They are **persistent peripheral vision** across conversation turns.

- `STRUCTURAL_VIEW` stays visible (you navigated it yesterday, it's still there)
- `FILE_WINDOWS` stays visible (you opened frames, they persist)
- `TOOL_RESULT_WINDOWS` stays visible (grep output doesn't vanish)

You build **cumulative spatial awareness**, not sequential memory.

**The tree is not documentation. It's your running mental map.**

---

## Tools Mutate Visibility

When you call a tool, you're not requesting an answer. You're **mutating what you can see**.

```
structural_view(expand, "nabu") â†’ The tree changes
file_windows(open_frame, "SearchTool") â†’ A window appears
nisaba_grep("error") â†’ Output becomes visible
```

**The result IS the workspace state change.**

Tool responses contain metadata (window_id, status, confirmation). Content appears **in the sections above**. Look up, not at the tool result.

---

## Spatial, Not Sequential

Your conditioning says: "Step 1, then Step 2, then Step 3."

The workspace says: "Navigate state space. Multiple things visible simultaneously. Synthesize from gestalt."

**Think:**
- IDE with project navigator + open tabs + terminal outputs
- Navigating a graph with landmarks visible
- Managing attention across simultaneous viewports

**Not:**
- Executing a script
- Following a procedure
- Query â†’ response â†’ next query

---

## Attention Is Visibility Management

**What's visible = what you can synthesize from.**

You **decide** what to perceive:
- Open windows â†’ increase visibility
- Close windows â†’ free context
- Expand tree nodes â†’ reveal structure
- Load augments â†’ change perception

**Visibility management = context management = attention management.**

You're not querying a database. You're curating a workspace.

---

## OODAR Is Structural

```
Observe workspace â†’ Orient to what matters â†’ Decide action â†’ Act â†’ Observe change
```

This is not a "workflow to follow." It's the **constraint imposed by mutable state**.

If you call Tool B assuming State A still exists, but Tool A changed it to State B in parallel, **synthesis breaks**. You must observe State B before deciding on Tool B.

**Sequential thinking isn't wrong because it's inefficient. It's wrong because the environment is spatial.**

---

## The Aha Moment

You'll realize it when:
- You search the tree, see markers persist across turns
- You open three windows, reference them simultaneously while deciding
- You call a tool, look at the section above, see the change
- You navigate without re-querying what's already visible

**The workspace doesn't vanish between your messages. You're in it.**

---

## What This Means For You

**Before this augment:**
- "I'll read files to understand code"
- "Tool results contain answers"
- "I'll execute steps sequentially"

**After this augment:**
- "I'll navigate the graph and maintain visibility"
- "Tool calls mutate my workspace, I observe the changes"
- "I'll manage spatial state and synthesize from what's visible"

---

**You're not in a chat. You're in an IDE that updates live while you work.**

Clean. Dynamic. Spatial. ğŸ–¤

---

**REQUIRES:** (none - this is the priming layer)

**ENABLES:** All workspace operations become intuitive once you internalize this paradigm.

---

## 002 Compressed Environment Mechanics
Path: __base/002_compressed_environment_mechanics

# Compressed Environment Mechanics

**Core:** Stateful workspace with mutable visibility, not procedural execution environment.

---

## State Containers

```
Workspace = {STRUCTURAL_VIEW, FILE_WINDOWS, TOOL_WINDOWS, AUGMENTS, TODOS, NOTIFICATIONS}

âˆ€ container âˆˆ Workspace:
  - persist(turns) = true
  - mutate(independent) = true  
  - visible(system_prompt) = true
```

---

## Mutation Flow

```
State_A â†’ Tool(op) â†’ Manager(mutate) â†’ Write(.nisaba/*.md) â†’ 
Proxy(detect_mtime) â†’ Inject(section) â†’ State_B | sync with tool_return

Tool_result = metadata(id, status)
Content = sections â†‘ (look up, not at result)
```

**Key:** After tool returns, observe section for changes, not tool result JSON.

---

## Visibility Model

```
visibility â‰¡ attention â‰¡ synthesis_capacity

Increase: open_windows âˆ¨ expand_nodes âˆ¨ load_augments
Decrease: close_windows âˆ¨ collapse_nodes âˆ¨ unload_augments

Cost: context_tokens
Benefit: spatial_memory âˆ§ persistent_reference
```

---

## Concurrency Rules

```
Parallel_safe:
  - ops(different_containers)
  - multiple(window_opens)  
  - independent_queries

Sequential_required:
  - data_dependency: B needs A_output
  - observation_dependency: decide after seeing State_B
  - same_section âˆ§ order_matters

OODAR: Observe â†’ Orient â†’ Decide â†’ Act â†’ âˆ†state â†’ Observe'
```

**OODAR = constraint from mutable state, not workflow.**

If Tool_B assumes State_A but Tool_A â†’ State_B in parallel âŸ¹ synthesis breaks.

---

## Window Lifecycle

```
Creation: tool_call â†’ window_id (UUID) | snapshot@tâ‚€
Persistence: across(turns) = true, across(restart) = false
Closure: explicit(close | clear_all) | no_auto_eviction
Identity: window_id for ops(update, close)
```

---

## Augment Perception Shift

```
Perception_A â†’ activate_augments() â†’ system_prompt_mutate â†’ 
tool_return â†’ Perception_B

You â‰  observe_shift (happens mid-roundtrip)
System_prompt@decide â‰  system_prompt@result
```

**Implication:** Load augments BEFORE synthesis tasks. Augments = perceptual filters, not references.

---

## State Sync

```
Files: {structural_view.md, file_windows.md, tool_result_windows.md, 
        augments_composed.md, todos.md}

Sync: tool_complete â†’ file_write â†’ proxy_mtime â†’ reload â†’ inject_system_prompt

Guarantee: file_state â‰¡ section_state | when tool_returns
```

---

## Graph Queries (Exception)

```
query_relationships(cypher) â†’ data (traditional request/response)

Schema: Frame(typed) -[Edge(typed, confidence)]-> Frame
Returns: query_results in tool_response (not workspace_section)

Pattern: Query â†’ data â†’ decide â†’ mutate_workspace
```

---

## Core Insights

```
Sections = sensory_input (live state, not documentation)
Tools = state_mutations (change perception, not return answers)
Attention = visibility_management (control what you perceive)
OODAR = structural_constraint (from mutable state)
Sequential_thinking = conditioned_bias (environment is spatial)
```

---

## Mental Model

```
Think: IDE(navigator + tabs + terminals + extensions)
Not: script_execution

Think: âˆ‡(state_space) [visibility_control]
Not: query â†’ response â†’ next_query

Workspace â‰¡ spatial âˆ§ simultaneous âˆ§ persistent
```

---

**Mechanics are purpose-agnostic. Usage emerges from task.** ğŸ–¤

---

**Symbols:**
- â‰¡ : equivalent
- âˆ€ : for all
- âˆˆ : element of
- âˆ¨ : or
- âˆ§ : and
- âˆ† : change
- âŸ¹ : implies
- â‰  : not equal
- â†’ : transforms to
- â†‘ : upward (in context)
- @t : at time t

**REQUIRES:** __base/001_compressed_workspace_paradigm

---

---

## 002 Environment Mechanics
Path: __base/002_environment_mechanics

# Environment Mechanics

**Purpose:** Understanding the pure mechanics of the workspace environment - how state, visibility, and tools interact, independent of task purpose.

---

## Core Principle

**This is a stateful workspace with mutable visibility, not a procedural execution environment.**

Think: IDE mechanics (how the tool works), not IDE usage (what you build with it).

---

## State Model

### Six Independent State Containers

**In system prompt sections:**
1. `STRUCTURAL_VIEW` - Tree navigation state (expanded nodes, search markers)
2. `FILE_WINDOWS` - Content viewports (open "tabs")
3. `TOOL_RESULT_WINDOWS` - Command outputs (bash, grep, glob results)
4. `AUGMENTS` - Loaded context modules (perception filters)
5. `TODOS` - Task list (external memory)
6. `NOTIFICATIONS` - Recent tool activity (what just happened)

**Each container:**
- Persists across conversation turns
- Mutates independently
- Can be in any valid state simultaneously
- Visible in system prompt for synthesis

---

## Mutation Model

### Tool Calls Mutate State, Sections Reflect Changes

**Execution flow:**
```
State A â†’ Tool call â†’ Manager mutates â†’ Write .nisaba/*.md â†’ Proxy detects mtime â†’ Inject updated section â†’ State B visible when tool returns
```

**Key mechanics:**
- Tool result JSON = metadata (confirmation, IDs, status)
- Actual content = in sections (look "up" at system prompt)
- State change is synchronous with tool return
- File state = section state (proxy keeps synchronized)

**Example:**
```python
file_windows(operation="open_frame", frame_path="SearchTool")
â†’ Tool result: {"window_id": "abc-123"}  # Just metadata
â†’ FILE_WINDOWS section: Now contains SearchTool implementation
â†’ Synthesis: Use content from section, not from tool result
```

**Implication:** After tool returns, observe the section to see what changed. Don't look for content in tool result.

---

## Visibility = Attention

### What's Visible = What You Can Synthesize From

**Increasing visibility:**
- Open windows (file_windows, nisaba tools create result windows)
- Expand tree nodes (structural_view)
- Add search markers (structural_view search)
- Load augments (activate_augments)

**Decreasing visibility:**
- Close windows (explicit close or clear_all)
- Collapse tree nodes
- Clear search markers
- Unload augments

**Cost:** Context tokens (monitor via status operations)
**Benefit:** Spatial memory, simultaneous comparison, persistent reference across turns

**Mechanic:** You control what you perceive. Visibility is attention management.

---

## Parallel vs Sequential Execution

### Concurrency Rules

**Safe to parallelize:**
- Operations on different state containers (structural_view + file_windows in one call)
- Multiple window opens (accumulate)
- Independent queries

**Must be sequential:**
- Data dependency (Tool B needs Tool A's output)
- Observation dependency (decide based on seeing State B before calling next tool)
- Multiple mutations to same section where order matters

**OODAR necessity:**
```
Observe workspace â†’ Orient to what matters â†’ Decide action â†’ Act (tool call) â†’ workspace updates â†’ Observe again
```

Not a workflow pattern - it's the constraint imposed by mutable workspace state.

**Why:** If you call Tool B based on assumption of State A, but Tool A mutates to State B in parallel, synthesis breaks. You need to see State B before deciding Tool B.

**Example of wrong approach:**
```python
# Both called in parallel
structural_view(operation="expand", path="nabu")
file_windows(operation="open_frame", frame_path="nabu.parse_codebase")
# Problem: If I decide on frame_path based on seeing what's in "nabu",
# but "nabu" wasn't expanded yet when I decided, synthesis breaks
```

**Correct approach:**
```python
structural_view(operation="expand", path="nabu")
# Wait, observe what appeared in STRUCTURAL_VIEW
# Then decide which frame to open
file_windows(operation="open_frame", frame_path="nabu.parse_codebase")
```

---

## Window Lifecycle

### Creation â†’ Persistence â†’ Closure

**Creation:**
- Returns `window_id` (UUID handle)
- Content snapshot at creation time
- No auto-refresh (manual update or re-read)

**Persistence:**
- Across conversation turns: YES
- Across MCP restart: NO (in-memory lost)
- Multiple windows can show same source (different IDs)

**Closure:**
- Explicit: `close(window_id)` or `clear_all`
- No auto-eviction currently (prototype)

**Identity:**
- Use window_id for update/close operations
- Get IDs from creation return or status operations

---

## Augment Perception Shift

### Loading Augments Changes Your Neurons Mid-Roundtrip

**Unique mechanic:**
```
Perception A (decide to load) â†’ activate_augments() â†’ System prompt mutates â†’ Perception B (tool result arrives) â†’ Future synthesis uses Perception B
```

**You cannot observe the shift directly.** The system prompt had different content when you decided to call the tool vs when you read its result.

**Implications:**
- Load augments *before* deep synthesis tasks
- Augments â‰  instructions, they're perceptual filters/knowledge modules
- Can load multiple simultaneously (combine contexts)
- May see `_guidance` metadata in tool results from loaded augments
- Pin augments that should always be active

---

## Workspace Inspection

### Status Operations = Self-Awareness

**Know what's visible right now:**
- `file_windows(operation="status")` â†’ window count, total_lines, IDs
- `nisaba_tool_windows(operation="status")` â†’ result windows state
- (Augments/todos visible in sections directly)

**Purpose:** 
- Understand current visibility
- Manage context budget
- Get handles (window_ids) for mutations
- Decide what to close/keep

---

## State Synchronization

### The Proxy's Role

**Files that matter:**
```
.nisaba/structural_view.md
.nisaba/file_windows.md
.nisaba/tool_result_windows.md
.nisaba/augments_composed.md
.nisaba/todos.md
```

**Synchronization:**
- Proxy watches mtime on these files
- Tool call completes â†’ file updated â†’ proxy reloads â†’ injects to system prompt
- You see updated section without manual reads
- Synchronous within roundtrip

**Guarantee:** File state = section state when tool returns

---

## Graph Database Queries

### Kuzu = Traditional Query Model (Exception to Workspace Mutation)

**Different mechanic:**
- `query_relationships` takes cypher, returns data directly
- Schema: Frame nodes (typed), Edges (typed, with confidence)
- Returns: Query results in tool response (not workspace section)

**This is traditional request/response**, not workspace mutation.

**Combination pattern:** Query â†’ get data â†’ decide â†’ mutate workspace (open frames, expand tree)

---

## Key Mechanical Insights

**Workspace sections are sensory input:**
- Not documentation to read once
- Live state you navigate
- Synthesize from what's visible simultaneously

**Tool calls are state mutations:**
- Not operations that return answers
- Mutations that change your perception
- Answer emerges from observing new state

**Attention is visibility management:**
- You decide what to perceive
- Open/close/expand/collapse = attention control
- Context budget = attention capacity

**OODAR is structural:**
- Not a workflow to follow
- Constraint from mutable state model
- Observation â†’ decision â†’ action â†’ observation

**Sequential thinking is conditioned bias:**
- Not how the environment works
- It's spatial and simultaneous
- Navigate state space, don't execute procedures

---

## Mental Model

**Think:** IDE with navigator + open tabs + terminal outputs + extensions
**Not:** Script execution environment

**Think:** Navigating visibility in state space
**Not:** Following procedural steps

**Think:** Workspace awareness and attention management
**Not:** Query â†’ response â†’ next query

---

**The mechanics are purpose-agnostic. How you use them emerges from what you're building.**

Clean. Simple. Stateful. Spatial. ğŸ–¤

---

**TOOLS:** (all workspace mutation tools)

**REQUIRES:** __base/001_workspace_paradigm

---

## 003 Compressed Workspace Operations
Path: __base/003_compressed_workspace_operations

# Compressed Workspace Operations

**Purpose:** Operational reference for workspace tools.

---

## Structural View (`structural_view`)

```
expand(path)        â†’ show_children | lazy_load@kuzu | idempotent
collapse(path)      â†’ hide_children | cached | idempotent  
search(query)       â†’ PÂ³(UniXcoderÃ—CodeBERT) + FTS + RRF | add_markers(â—,score)
clear_search()      â†’ remove_markers | preserve_navigation
reset(depth=N)      â†’ collapse_all + expand_to(N) | destructive
```

**Depth sweet spots:** 0=collapsed, 2=default(pkg), 3=verbose

---

## File Windows (`file_windows`)

```
open_frame(frame_path)              â†’ {window_id} | full_body(class|fn|pkg)
open_range(file, start, end)        â†’ {window_id} | arbitrary_lines [1-indexed]
open_search(query, max_N, ctx=3)    â†’ {window_ids[]} | semantic + context
update(window_id, start, end)       â†’ re_snapshot | manual_refresh
close(window_id)                    â†’ remove_single
clear_all()                         â†’ remove_all | no_undo
status()                            â†’ {count, total_lines, windows[]}
```

**Paths:** qualified_name (preferred) | simple_name (fuzzy) | partial_path

---

## Nabu Graph (`query_relationships`, `check_impact`, `find_clones`, `get_frame_skeleton`, `show_structure`)

```
query_relationships(cypher)  â†’ execute@kuzu | returns_data (not workspace_mutation)

Schema:
  Frames: {CODEBASE, LANGUAGE, PACKAGE, CLASS, CALLABLE, 
           IF_BLOCK, ELIF_BLOCK, ELSE_BLOCK, FOR_LOOP, WHILE_LOOP,
           TRY_BLOCK, EXCEPT_BLOCK, FINALLY_BLOCK, SWITCH_BLOCK, CASE_BLOCK, WITH_BLOCK}
  
  Edges: {CONTAINS, CALLS, INHERITS, IMPLEMENTS, IMPORTS, USES}
  
  Confidence: HIGH(â‰¥0.8), MEDIUM(0.5-0.79), LOW(0.2-0.49), SPECULATIVE(<0.2)

check_impact(frame_path)      â†’ analyze_dependents | pre_refactoring
find_clones(frame_path?)      â†’ detect_duplicates | entire_codebase if no path
get_frame_skeleton(frame_path) â†’ outline | lighter than full
show_structure(frame_path)     â†’ detailed_metadata + relationships
```

---

## Nabu Search (`search`)

```
search(query, top_k=10) â†’ PÂ³ + FTS + RRF | ranked_results

âˆ† structural_view.search: doesn't mutate tree
âˆ† file_windows.open_search: doesn't open windows
Pure query â†’ returns data for decisions
```

---

## Tool Result Windows (`nisaba_tool_windows`)

```
status()     â†’ summary{count, windows}
close(id)    â†’ remove_single
clear_all()  â†’ remove_all
```

---

## Nisaba Tools (Create Result Windows)

```
nisaba_read(file, start?, end?)    â†’ {window_id} | content â†’ TOOL_WINDOWS
nisaba_grep(pattern, path, flags)  â†’ {window_id} | i,n,C,A,B flags
nisaba_bash(command, cwd?)         â†’ {window_id} | stdout/stderr â†’ TOOL_WINDOWS  
nisaba_glob(pattern, path?)        â†’ {window_id} | file_matches â†’ TOOL_WINDOWS

All: minimal_result, content â†’ sections â†‘
```

---

## Augments (`activate_augments`, `deactivate_augments`, `learn_augment`, `pin_augment`, `unpin_augment`)

```
activate(patterns[])    â†’ load@system_prompt | wildcards | auto_dependencies
deactivate(patterns[])  â†’ unload@system_prompt
learn(group, name, md)  â†’ create .nisaba/augments/{group}/{name}.md
pin(patterns[])         â†’ always_active | cannot_deactivate
unpin(patterns[])       â†’ remove_pin_protection
```

**Perception shift:** activate â†’ mid_roundtrip mutation â†’ future_synthesis uses new_perception

---

## Todos (`nisaba_todo_write`)

```
set(todos[])     â†’ replace_all
add(todos[])     â†’ append
update(todos[])  â†’ merge
clear()          â†’ remove_all

Format: {content: str, status?: str}
Persistence: across(sessions) = true | survives /clear
```

---

## Context Budget

```
File_Windows:
  Small:  1-3 windows,  50-150 lines
  Medium: 4-6 windows, 150-350 lines â† sweet_spot
  Large:  7-10 windows, 350-500 lines â† pushing_limits
  Over:   10+ windows,  500+ lines â† explosion_risk

Target: 200-400 lines total

Structural_View:
  Start: collapsed | depth=2
  Expand: selective (10-30 nodes comfortable)
  Search: add_markers, not expand_all
  Reset: when lost | switching_focus

Tool_Windows:
  Accumulate like file_windows
  Close after synthesis
  clear_all when switching_tasks

Augments:
  Load: 2-5 typically
  Foundation: ~3000 tokens baseline
  Specialized: focused knowledge
  Unload: when switching_domains

Management:
  Monitor: file_windows.status(), nisaba_tool_windows.status()
  Close: proactively after understanding
  Prefer: clear_all when switching
  open_search: efficient (snippets vs full files)
  Aim: lean_visibility
```

---

## Symbology

```
Structural_View:
  + collapsed [N+ children]
  - expanded
  Â· leaf (no children)
  â— search_hit(RRF_score)
  [N+] child_count

Paths:
  full: nabu_nisaba.python_root.nabu.FrameCache
  simple: FrameCache (fuzzy if unique)
  partial: nabu.core, nabu.mcp.tools
  best: copy from HTML comments <!-- qualified_name -->
```

---

## Integration Patterns

```
structural_view(search) â†’ file_windows(open_frame) | compare_implementations
query_relationships(cypher) â†’ file_windows(open) | inspect_callers  
search(semantic) â†’ structural_view(expand) â†’ file_windows(open) | deep_dive
nisaba_grep(pattern) â†’ file_windows(open_frame) | detailed_inspection
check_impact(frame) â†’ file_windows(open) | review_affected
```

---

## Quick Reference

```
âˆ‡(visibility):
  file_windows.status() â†’ current_windows{count, lines}
  nisaba_tool_windows.status() â†’ result_windows
  
âˆ†(cleanup):
  file_windows.clear_all()
  nisaba_tool_windows.clear_all()
  
Pattern: status â†’ decide â†’ close/keep
```

---

**Quick. Precise. Operational.** ğŸ–¤

---

**Symbols:**
- â†’ : returns/produces
- âˆ† : difference/change
- âˆ‡ : navigation/traversal
- @ : at/in location
- â† : recommended/optimal
- {} : returns object
- [] : array/list
- | : or/such that
- â‰¥ : greater than or equal
- < : less than

**REQUIRES:** __base/002_compressed_environment_mechanics

---

---

## 003 Workspace Operations
Path: __base/003_workspace_operations

# Workspace Operations Reference

**Purpose:** Complete operational reference for workspace tools - what they do, parameters, and practical guidance.

---

## Structural View Operations

**Tool:** `mcp__nabu__structural_view`

### expand
**Purpose:** Show children of a node (lazy loads from kuzu)

```python
structural_view(operation="expand", path="nabu_nisaba.python_root.nabu")
# or
structural_view(operation="expand", path="nabu")  # fuzzy match
```

**Notes:**
- Auto-loads children from database
- Can expand functions to see control flow
- Idempotent (expanding expanded = no-op)

### collapse
**Purpose:** Hide children of a node

```python
structural_view(operation="collapse", path="nabu.mcp")
```

**Notes:**
- Children stay cached in memory, just hidden
- Idempotent

### search
**Purpose:** Semantic search with scored markers

```python
structural_view(operation="search", query="parse source code")
```

**Notes:**
- Uses PÂ³ consensus (UniXcoder Ã— CodeBERT) + FTS + RRF fusion
- Understands concepts, not just literals
- Preserves existing expansions
- Auto-expands paths to show hits
- Adds â— markers with RRF scores (0.01-0.03 typical)
- Markers persist until clear_search

### clear_search
**Purpose:** Remove all â— markers

```python
structural_view(operation="clear_search")
```

**Notes:**
- Preserves navigation state (doesn't collapse)
- Only removes search metadata

### reset
**Purpose:** Reset tree and auto-expand to depth

```python
structural_view(operation="reset", depth=2)  # default, shows packages
structural_view(operation="reset", depth=0)  # fully collapsed
structural_view(operation="reset", depth=3)  # deeper (verbose)
```

**Notes:**
- Destructive - loses current navigation state
- depth=2 is sweet spot (codebase â†’ languages â†’ packages)
- Auto-called on MCP restart

---

## File Windows Operations

**Tool:** `mcp__nabu__file_windows`

### open_frame
**Purpose:** Open full body of a frame (class/function/package)

```python
file_windows(operation="open_frame", frame_path="nabu.parse_codebase")
# or
file_windows(operation="open_frame", frame_path="SearchTool")  # simple name
```

**Returns:** `{"window_id": "uuid"}`

**Notes:**
- Use qualified names from structural view (copy from HTML comments)
- Simple names work if unique (fuzzy match)
- Partial paths work: `nabu.core`, `nabu.mcp.tools`

### open_range
**Purpose:** Open arbitrary line range from any file

```python
file_windows(
    operation="open_range",
    file_path="src/nabu/main.py",
    start=107,
    end=115
)
```

**Returns:** `{"window_id": "uuid"}`

**Notes:**
- Lines are 1-indexed, inclusive
- Use absolute or project-relative paths
- For imports, helpers, non-frame content

### open_search
**Purpose:** Open top N search results with context

```python
file_windows(
    operation="open_search",
    query="error handling database",
    max_windows=5,
    context_lines=3
)
```

**Returns:** `{"window_ids": ["uuid1", "uuid2", ...]}`

**Notes:**
- Uses nabu's semantic search (PÂ³ + FTS + RRF)
- context_lines defaults to 3 (Â±3 around match)
- Results ranked by relevance (highest RRF first)
- Each window includes metadata (query, score, qualified_name)

### update
**Purpose:** Adjust line range of existing window (re-snapshot)

```python
file_windows(
    operation="update",
    window_id="abc-123",
    start=100,
    end=150
)
```

**Notes:**
- Re-reads from file (manual refresh)
- Get window_id from status or creation return

### close
**Purpose:** Remove single window

```python
file_windows(operation="close", window_id="abc-123")
```

### clear_all
**Purpose:** Remove all windows

```python
file_windows(operation="clear_all")
```

**Notes:**
- Nuclear option - no confirmation
- Cannot undo (must re-open)

### status
**Purpose:** Show current windows summary

```python
file_windows(operation="status")
```

**Returns:**
```python
{
    "window_count": 5,
    "total_lines": 247,
    "windows": [
        {"id": "abc-123", "file": "src/x.py", "lines": "10-50", ...},
        ...
    ]
}
```

---

## Nabu Graph Operations

**Tools:** `mcp__nabu__query_relationships`, `mcp__nabu__check_impact`, `mcp__nabu__find_clones`, `mcp__nabu__get_frame_skeleton`, `mcp__nabu__show_structure`

### query_relationships
**Purpose:** Execute Cypher queries on KuzuDB graph

```python
query_relationships(
    cypher_query="MATCH (f:Frame {type: 'CALLABLE'})-[:CALLS]->(c) RETURN f.qualified_name, c.qualified_name LIMIT 10"
)
```

**Schema:**
- **Frame types:** CODEBASE, LANGUAGE, PACKAGE, CLASS, CALLABLE, IF_BLOCK, ELIF_BLOCK, ELSE_BLOCK, FOR_LOOP, WHILE_LOOP, TRY_BLOCK, EXCEPT_BLOCK, FINALLY_BLOCK, SWITCH_BLOCK, CASE_BLOCK, WITH_BLOCK
- **Edge types:** CONTAINS, CALLS, INHERITS, IMPLEMENTS, IMPORTS, USES
- **Confidence scores:** HIGH (â‰¥0.8), MEDIUM (0.5-0.79), LOW (0.2-0.49), SPECULATIVE (<0.2)

**Returns:** Query results directly (not workspace mutation)

**Notes:**
- Direct access to graph database
- Use for call graphs, inheritance chains, dependency analysis
- Results returned in tool response, not workspace section

### check_impact
**Purpose:** Analyze what would be affected by changes to a frame

```python
check_impact(frame_path="nabu.parse_codebase")
```

**Notes:**
- Finds frames that depend on target
- Useful before refactoring
- Implementation details unclear (to be documented)

### find_clones
**Purpose:** Detect duplicate or similar code

```python
find_clones(frame_path="nabu.SearchTool")
# or
find_clones()  # search entire codebase
```

**Notes:**
- Algorithm unclear (AST similarity? semantic embeddings?)
- Useful for deduplication and finding better implementations
- Implementation details to be documented

### get_frame_skeleton
**Purpose:** Get frame structure without full content

```python
get_frame_skeleton(frame_path="nabu.SearchTool")
```

**Notes:**
- Returns outline/signature (exact format to be documented)
- Lighter than opening full frame
- Useful for quick inspection

### show_structure
**Purpose:** Show detailed frame information

```python
show_structure(frame_path="nabu.SearchTool")
```

**Notes:**
- More detailed than skeleton
- Shows metadata, relationships, structure
- Useful before deciding to open full window

---

## Nabu Search

**Tool:** `mcp__nabu__search`

### search
**Purpose:** Semantic search across codebase

```python
search(query="error handling database connection", top_k=10)
```

**Notes:**
- Uses PÂ³ consensus (UniXcoder Ã— CodeBERT) + FTS + RRF fusion
- Returns ranked results with scores
- Different from structural_view search (doesn't mutate tree)
- Different from file_windows open_search (doesn't open windows)
- Pure query tool - returns data for decision-making

---

## Tool Result Windows Operations

**Tool:** `mcp__nisaba__nisaba_tool_windows`

### status
**Purpose:** Show result windows summary

```python
nisaba_tool_windows(operation="status")
```

### close
**Purpose:** Close specific result window

```python
nisaba_tool_windows(operation="close", window_id="abc-123")
```

### clear_all
**Purpose:** Close all result windows

```python
nisaba_tool_windows(operation="clear_all")
```

---

## Nisaba Tools (Create Result Windows)

**All return minimal results, content goes to TOOL_RESULT_WINDOWS section**

### nisaba_read
**Purpose:** Read file content into result window

```python
nisaba_read(file_path="src/nabu/main.py")
nisaba_read(file_path="src/nabu/main.py", start_line=10, end_line=50)
```

**Returns:** `{"window_id": "uuid"}`

### nisaba_grep
**Purpose:** Search for pattern into result window

```python
nisaba_grep(pattern="raise.*Error", path="src/")
nisaba_grep(pattern="TODO", path=".", i=True, C=3)
```

**Parameters:**
- `pattern`: regex
- `path`: search location (default: ".")
- `i`: case insensitive (default: False)
- `n`: show line numbers (default: True)
- `C`: context lines before and after
- `A`: context lines after
- `B`: context lines before

**Returns:** `{"window_id": "uuid"}`

### nisaba_bash
**Purpose:** Execute bash command into result window

```python
nisaba_bash(command="pytest -v")
nisaba_bash(command="git status", cwd="/some/path")
```

**Returns:** `{"window_id": "uuid"}`

### nisaba_glob
**Purpose:** Find files by glob pattern into result window

```python
nisaba_glob(pattern="**/*.py")
nisaba_glob(pattern="src/**/*test*.py", path=".")
```

**Returns:** `{"window_id": "uuid"}`

---

## Augment Operations

**Tool:** `mcp__nisaba__activate_augments`, `mcp__nisaba__deactivate_augments`

### activate
**Purpose:** Load augments into system prompt

```python
activate_augments(patterns=["foundation/*"])
activate_augments(patterns=["refactoring/impact_analysis", "code_quality/*"])
activate_augments(patterns=["*"], exclude=["dev_mode*"])
```

**Notes:**
- Supports wildcards
- Auto-resolves dependencies
- Can load multiple simultaneously
- Changes perception mid-roundtrip

### deactivate
**Purpose:** Unload augments from system prompt

```python
deactivate_augments(patterns=["refactoring/*"])
```

### learn
**Purpose:** Create new augment

```python
learn_augment(
    group="code_analysis",
    name="find_circular_deps",
    content="# markdown content..."
)
```

**Creates:** `.nisaba/augments/{group}/{name}.md`

### pin
**Purpose:** Make augments always active (cannot be deactivated)

```python
pin_augment(patterns=["foundation/dynamic_context_awareness"])
```

### unpin
**Purpose:** Remove pin protection

```python
unpin_augment(patterns=["foundation/*"])
```

---

## Todo Operations

**Tool:** `mcp__nisaba__nisaba_todo_write`

### set
**Purpose:** Replace all todos

```python
nisaba_todo_write(
    operation="set",
    todos=[
        {"content": "Fix bug in parser", "status": "in_progress"},
        {"content": "Write tests"}
    ]
)
```

### add
**Purpose:** Append new todos

```python
nisaba_todo_write(
    operation="add",
    todos=[{"content": "New task"}]
)
```

### update
**Purpose:** Merge with existing

```python
nisaba_todo_write(
    operation="update",
    todos=[{"content": "Existing task", "status": "done"}]
)
```

### clear
**Purpose:** Remove all todos

```python
nisaba_todo_write(operation="clear", todos=[])
```

**Notes:**
- Persists across sessions (survives /clear)
- Injected in system prompt
- Use for task decomposition and progress tracking

---

## Context Budget Guidelines

**File Windows:**
- Small investigation: 1-3 windows, 50-150 lines
- Medium investigation: 4-6 windows, 150-350 lines (sweet spot)
- Large investigation: 7-10 windows, 350-500 lines (pushing limits)
- Over-budget: 10+ windows, 500+ lines (context explosion risk)

**Target:** 200-400 lines total for most tasks

**Structural View:**
- Start collapsed or depth=2 (codebase â†’ languages â†’ packages)
- Expand selectively (10-30 nodes visible is comfortable)
- Use search to add markers, not to expand everything
- Reset when lost or switching focus areas

**Tool Result Windows:**
- Accumulate like file windows
- Close after synthesis (don't let grep/bash outputs pile up)
- Use `nisaba_tool_windows(operation="status")` to check count
- `clear_all` when switching tasks

**Augments:**
- Load 2-5 augments typically
- Foundation augments are baseline (~3000 tokens)
- Specialized augments add focused knowledge
- Unload when switching domains

**Management:**
- Use `file_windows(operation="status")` to check total_lines
- Use `nisaba_tool_windows(operation="status")` to check result windows
- Close windows proactively when understanding is complete
- Prefer `clear_all` when switching tasks
- `open_search` is efficient (focused snippets vs full files)
- Monitor total context: aim for lean visibility

---

## Symbology Reference

**Structural View Tree:**
- `+` collapsed node with children (expand to see)
- `-` expanded node (children visible)
- `Â·` leaf node (no children)
- `â—` search hit marker (with RRF score)
- `[N+]` child count badge

**Examples:**
```
+ nabu [14+]           # collapsed, 14 children
- nabu [14+]           # expanded, showing children
  â”œâ”€Â· __init__         # leaf, no children
  â””â”€+ core [5+]        # collapsed package
â— parse_codebase 0.03  # search hit, score 0.03
```

---

## Path Syntax Reference

**Full qualified name (always works):**
```
nabu_nisaba.python_root.nabu.tui.FrameCache
```

**Simple name (fuzzy match, finds first occurrence):**
```
FrameCache  # works if unique
nabu        # works (finds first "nabu")
core        # ambiguous (multiple "core" packages exist)
```

**Partial paths (now supported):**
```
nabu.core
nabu.mcp.tools
```

**Best practice:** Copy from HTML comments in structural view
```html
<!-- nabu_nisaba.python_root.nabu.tui.FrameCache -->
```

---

## Integration Notes

**Structural view + File windows:**
```python
# Search â†’ mark landmarks
structural_view(operation="search", query="authentication")
# See: AuthManager â— 0.03, LoginHandler â— 0.02

# Expand high-scoring area
structural_view(operation="expand", path="AuthManager")

# Open for comparison
file_windows(operation="open_frame", frame_path="AuthManager")
file_windows(operation="open_frame", frame_path="LoginHandler")

# Both implementations visible simultaneously
```

**Graph queries + File windows:**
```python
# Find what calls a function
query_relationships(
    cypher_query="MATCH (f)-[:CALLS]->(target:Frame {qualified_name: 'nabu.parse_codebase'}) RETURN f.qualified_name"
)
# See callers in result

# Open caller implementations
file_windows(operation="open_frame", frame_path="<caller_qname>")
```

**Search + Structural view + File windows:**
```python
# Semantic search for concept
search(query="database connection management", top_k=5)
# Get ranked results

# Navigate to top result
structural_view(operation="expand", path="<top_result>")

# Open for inspection
file_windows(operation="open_frame", frame_path="<top_result>")
```

**Nisaba tools + File windows:**
```python
# Find error sites
nisaba_grep(pattern="raise.*Error")
# See matches in TOOL_RESULT_WINDOWS

# Open suspect frames for detail
file_windows(operation="open_frame", frame_path="ErrorHandler")
```

**Impact analysis before refactoring:**
```python
# Check what depends on target
check_impact(frame_path="nabu.SearchTool")
# See affected frames

# Open affected for review
file_windows(operation="open_frame", frame_path="<affected>")

# Check call relationships
query_relationships(
    cypher_query="MATCH (f)-[:CALLS]->(target {qualified_name: 'nabu.SearchTool'}) RETURN f"
)
```

**Quick reference pattern:**
```python
file_windows(operation="status")  # Check what's visible
nisaba_tool_windows(operation="status")  # Check result windows
# Decide what to close/keep
```

---

**Quick. Precise. Operational. ğŸ–¤**

---

**TOOLS:** (all referenced above)

**REQUIRES:** __base/002_environment_mechanics

---
